<html lang="en">
<head>
<title>CFFI User Manual</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="CFFI User Manual">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 2005 James Bielman <jamesjb at jamesjb.com>

Copyright (C) 2005-2010 Lui's Oliveira
  <loliveira at common-lisp.net>

Copyright (C) 2005-2006 Dan Knapp <danka at accela.net>
Copyright (C) 2005-2006 Emily Backes <lucca at accela.net>
Copyright (C) 2006 Stephen Compall <s11 at member.fsf.org>

     Permission is hereby granted, free of charge, to any person
     obtaining a copy of this software and associated documentation
     files (the "Software"), to deal in the Software without
     restriction, including without limitation the rights to use, copy,
     modify, merge, publish, distribute, sublicense, and/or sell copies
     of the Software, and to permit persons to whom the Software is
     furnished to do so, subject to the following conditions:

     The above copyright notice and this permission notice shall be
     included in all copies or substantial portions of the Software.

     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
     MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
     NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
     DEALINGS IN THE SOFTWARE.
   -->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
body {font-family: century schoolbook, serif;
      line-height: 1.3;
      padding-left: 5em; padding-right: 1em;
      padding-bottom: 1em; max-width: 60em;}
table {border-collapse: collapse}
span.roman { font-family: century schoolbook, serif; font-weight: normal; }
h1, h2, h3, h4, h5, h6 {font-family:  Helvetica, sans-serif}
h4 { margin-top: 2.5em; }
dfn {font-family: inherit; font-variant: italic; font-weight: bolder }
kbd {font-family: monospace; text-decoration: underline}
/*var {font-family: Helvetica, sans-serif; font-variant: slanted}*/
var {font-variant: slanted;}
td  {padding-right: 1em; padding-left: 1em}
sub {font-size: smaller}
.node {padding: 0; margin: 0}

.lisp { font-family: monospace;
        background-color: #F4F4F4; border: 1px solid #AAA;
        padding-top: 0.5em; padding-bottom: 0.5em; }

/* coloring */

.lisp-bg { background-color: #F4F4F4 ; color: black; }
.lisp-bg:hover { background-color: #F4F4F4 ; color: black; }

.symbol { font-weight: bold; color: #770055; background-color : transparent; border: 0px; margin: 0px;}
a.symbol:link { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:active { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:visited { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
a.symbol:hover { font-weight: bold; color : #229955; background-color : transparent; text-decoration: none; border: 0px; margin: 0px; }
.special { font-weight: bold; color: #FF5000; background-color: inherit; }
.keyword { font-weight: bold; color: #770000; background-color: inherit; }
.comment { font-weight: normal; color: #007777; background-color: inherit; }
.string  { font-weight: bold; color: #777777; background-color: inherit; }
.character   { font-weight: bold; color: #0055AA; background-color: inherit; }
.syntaxerror { font-weight: bold; color: #FF0000; background-color: inherit; }
span.paren1 { font-weight: bold; color: #777777; }
span.paren1:hover { color: #777777; background-color: #BAFFFF; }
span.paren2 { color: #777777; }
span.paren2:hover { color: #777777; background-color: #FFCACA; }
span.paren3 { color: #777777; }
span.paren3:hover { color: #777777; background-color: #FFFFBA; }
span.paren4 { color: #777777; }
span.paren4:hover { color: #777777; background-color: #CACAFF; }
span.paren5 { color: #777777; }
span.paren5:hover { color: #777777; background-color: #CAFFCA; }
span.paren6 { color: #777777; }
span.paren6:hover { color: #777777; background-color: #FFBAFF; }
--></style>
</head>
<body>
<h1 class="settitle">CFFI User Manual</h1>
   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">cffi</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<li><a name="toc_Installation" href="#Installation">2 Installation</a>
<li><a name="toc_Implementation-Support" href="#Implementation-Support">3 Implementation Support</a>
<ul>
<li><a href="#Implementation-Support">3.1 Limitations</a>
</li></ul>
<li><a name="toc_Tutorial" href="#Tutorial">4 An Introduction to Foreign Interfaces and <acronym>CFFI</acronym></a>
<ul>
<li><a href="#Tutorial_002dComparison">4.1 What makes Lisp different</a>
<li><a href="#Tutorial_002dGetting-a-URL">4.2 Getting a <acronym>URL</acronym></a>
<li><a href="#Tutorial_002dLoading">4.3 Loading foreign libraries</a>
<li><a href="#Tutorial_002dInitializing">4.4 Initializing <code>libcurl</code></a>
<li><a href="#Tutorial_002deasy_005fsetopt">4.5 Setting download options</a>
<li><a href="#Tutorial_002dAbstraction">4.6 Breaking the abstraction</a>
<li><a href="#Tutorial_002dLisp-easy_005fsetopt">4.7 Option functions in Lisp</a>
<li><a href="#Tutorial_002dMemory">4.8 Memory management</a>
<li><a href="#Tutorial_002dCallbacks">4.9 Calling Lisp from C</a>
<li><a href="#Tutorial_002dCompletion">4.10 A complete <acronym>FFI</acronym>?</a>
<li><a href="#Tutorial_002dTypes">4.11 Defining new types</a>
<li><a href="#Tutorial_002dConclusion">4.12 What's next?</a>
</li></ul>
<li><a name="toc_Wrapper-generators" href="#Wrapper-generators">5 Wrapper generators</a>
<li><a name="toc_Foreign-Types" href="#Foreign-Types">6 Foreign Types</a>
<ul>
<li><a href="#Built_002dIn-Types">6.1 Built-In Types</a>
<li><a href="#Other-Types">6.2 Other Types</a>
<li><a href="#Defining-Foreign-Types">6.3 Defining Foreign Types</a>
<li><a href="#Foreign-Type-Translators">6.4 Foreign Type Translators</a>
<li><a href="#Optimizing-Type-Translators">6.5 Optimizing Type Translators</a>
<li><a href="#Foreign-Structure-Types">6.6 Foreign Structure Types</a>
<li><a href="#Allocating-Foreign-Objects">6.7 Allocating Foreign Objects</a>
</li></ul>
<li><a name="toc_Pointers" href="#Pointers">7 Pointers</a>
<ul>
<li><a href="#Basic-Pointer-Operations">7.1 Basic Pointer Operations</a>
<li><a href="#Allocating-Foreign-Memory">7.2 Allocating Foreign Memory</a>
<li><a href="#Accessing-Foreign-Memory">7.3 Accessing Foreign Memory</a>
</li></ul>
<li><a name="toc_Strings" href="#Strings">8 Strings</a>
<li><a name="toc_Variables" href="#Variables">9 Variables</a>
<li><a name="toc_Functions" href="#Functions">10 Functions</a>
<li><a name="toc_Libraries" href="#Libraries">11 Libraries</a>
<ul>
<li><a href="#Defining-a-library">11.1 Defining a library</a>
<li><a href="#Library-definition-style">11.2 Library definition style</a>
</li></ul>
<li><a name="toc_Callbacks" href="#Callbacks">12 Callbacks</a>
<li><a name="toc_The-Groveller" href="#The-Groveller">13 The Groveller</a>
<ul>
<li><a href="#The-Groveller">13.1 Building FFIs with CFFI-Grovel</a>
<li><a href="#Groveller-Syntax">13.2 Specification File Syntax</a>
<li><a href="#Groveller-ASDF-Integration">13.3 ASDF Integration</a>
<li><a href="#Groveller-Implementation-Notes">13.4 Implementation Notes</a>
</li></ul>
<li><a name="toc_Limitations" href="#Limitations">14 Limitations</a>
<li><a name="toc_Platform_002dspecific-features" href="#Platform_002dspecific-features">Appendix A Platform-specific features</a>
<li><a name="toc_Glossary" href="#Glossary">Appendix B Glossary</a>
<li><a name="toc_Comprehensive-Index" href="#Comprehensive-Index">Index</a>
</li></ul>
</div>



<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dir">(dir)</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">cffi</h2>

<p>Copyright &copy; 2005 James Bielman &lt;jamesjb at jamesjb.com&gt; <br>
Copyright &copy; 2005-2010 Lu&iacute;s Oliveira
  &lt;loliveira at common-lisp.net&gt; <br>
Copyright &copy; 2005-2006 Dan Knapp &lt;danka at accela.net&gt;
Copyright &copy; 2005-2006 Emily Backes &lt;lucca at accela.net&gt;
Copyright &copy; 2006 Stephen Compall &lt;s11 at member.fsf.org&gt;

   <blockquote>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
&ldquo;Software&rdquo;), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

   <p>The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

   <p><span class="sc">The software is provided &ldquo;as is&rdquo;, without warranty of any kind,
express or implied, including but not limited to the warranties of
merchantability, fitness for a particular purpose and noninfringement. 
In no event shall the authors or copyright holders be liable for any
claim, damages or other liability, whether in an action of contract,
tort or otherwise, arising from, out of or in connection with the
software or the use or other dealings in the software.</span>
</blockquote>

<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>:                 What is CFFI? 
<li><a accesskey="2" href="#Installation">Installation</a>
<li><a accesskey="3" href="#Implementation-Support">Implementation Support</a>
<li><a accesskey="4" href="#Tutorial">Tutorial</a>:                     Interactive intro to using CFFI. 
<li><a accesskey="5" href="#Wrapper-generators">Wrapper generators</a>:           CFFI forms from munging C source code. 
<li><a accesskey="6" href="#Foreign-Types">Foreign Types</a>
<li><a accesskey="7" href="#Pointers">Pointers</a>
<li><a accesskey="8" href="#Strings">Strings</a>
<li><a accesskey="9" href="#Variables">Variables</a>
<li><a href="#Functions">Functions</a>
<li><a href="#Libraries">Libraries</a>
<li><a href="#Callbacks">Callbacks</a>
<li><a href="#The-Groveller">The Groveller</a>
<li><a href="#Limitations">Limitations</a>
<li><a href="#Platform_002dspecific-features">Platform-specific features</a>:   Details about the underlying system. 
<li><a href="#Glossary">Glossary</a>:                     List of CFFI-specific terms and meanings. 
<li><a href="#Comprehensive-Index">Comprehensive Index</a>

</li></ul>
<p>--- Dictionary ---

<p>Foreign Types

</p>
<ul class="menu">
<li><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a>:         Outside interface to backward type translator. 
<li><a href="#convert_002dto_002dforeign">convert-to-foreign</a>:           Outside interface to forward type translator. 
<li><a href="#defbitfield">defbitfield</a>:                  Defines a bitfield. 
<li><a href="#defcstruct">defcstruct</a>:                   Defines a C structure type. 
<li><a href="#defcunion">defcunion</a>:                    Defines a C union type. 
<li><a href="#defctype">defctype</a>:                     Defines a foreign typedef. 
<li><a href="#defcenum">defcenum</a>:                     Defines a C enumeration. 
<li><a href="#define_002dforeign_002dtype">define-foreign-type</a>:          Defines a foreign type specifier. 
<li><a href="#define_002dparse_002dmethod">define-parse-method</a>:          Specifies how a type should be parsed. 
<!-- * explain-foreign-slot-value::  <unimplemented> -->
<li><a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>:     Returns a list of symbols for a bitfield type. 
<li><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>:       Calculates a value for a bitfield type. 
<li><a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>:         Finds a keyword in an enum type. 
<li><a href="#foreign_002denum_002dvalue">foreign-enum-value</a>:           Finds a value in an enum type. 
<li><a href="#foreign_002dslot_002dnames">foreign-slot-names</a>:           Returns a list of slot names in a foreign struct. 
<li><a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>:          Returns the offset of a slot in a foreign struct. 
<li><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>:         Returns a pointer to a slot in a foreign struct. 
<li><a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>:           Returns the value of a slot in a foreign struct. 
<li><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>:       Returns the alignment of a foreign type. 
<li><a href="#foreign_002dtype_002dsize">foreign-type-size</a>:            Returns the size of a foreign type. 
<li><a href="#free_002dconverted_002dobject">free-converted-object</a>:        Outside interface to typed object deallocators. 
<li><a href="#free_002dtranslated_002dobject">free-translated-object</a>:       Defines how to free a oreign object. 
<li><a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>:       Defines a foreign-to-Lisp object translation. 
<li><a href="#translate_002dto_002dforeign">translate-to-foreign</a>:         Defines a Lisp-to-foreign object translation. 
<li><a href="#with_002dforeign_002dobject">with-foreign-object</a>:          Allocates a foreign object with dynamic extent. 
<li><a href="#with_002dforeign_002dobjects">with-foreign-objects</a>:         Plural form of <code>with-foreign-object</code>. 
<li><a href="#with_002dforeign_002dslots">with-foreign-slots</a>:           Accesses the slots of a foreign structure.

</li></ul>
<p>Pointers

</p>
<ul class="menu">
<li><a href="#foreign_002dfree">foreign-free</a>:                 Deallocates memory. 
<li><a href="#foreign_002dalloc">foreign-alloc</a>:                Allocates memory. 
<li><a href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a>:       Returns a pointer to a foreign symbol. 
<li><a href="#inc_002dpointer">inc-pointer</a>:                  Increments the address held by a pointer. 
<li><a href="#incf_002dpointer">incf-pointer</a>:                 Increments the pointer address in a place. 
<li><a href="#make_002dpointer">make-pointer</a>:                 Returns a pointer to a given address. 
<li><a href="#mem_002daptr">mem-aptr</a>:                     The pointer to an element of an array. 
<li><a href="#mem_002daref">mem-aref</a>:                     Accesses the value of an index in an array. 
<li><a href="#mem_002dref">mem-ref</a>:                      Dereferences a pointer. 
<li><a href="#null_002dpointer">null-pointer</a>:                 Returns a NULL pointer. 
<li><a href="#null_002dpointer_002dp">null-pointer-p</a>:               Tests a pointer for NULL value. 
<li><a href="#pointerp">pointerp</a>:                     Tests whether an object is a pointer or not. 
<li><a href="#pointer_002daddress">pointer-address</a>:              Returns the address pointed to by a pointer. 
<li><a href="#pointer_002deq">pointer-eq</a>:                   Tests if two pointers point to the same address. 
<li><a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>:         Allocates memory with dynamic extent.

</li></ul>
<p>Strings

</p>
<ul class="menu">
<li><a href="#g_t_002adefault_002dforeign_002dencoding_002a">*default-foreign-encoding*</a>:   Default encoding for the string types. 
<li><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>:         Converts a Lisp string to a foreign string. 
<li><a href="#foreign_002dstring_002dfree">foreign-string-free</a>:          Deallocates memory used by a foreign string. 
<li><a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a>:       Converts a foreign string to a Lisp string. 
<li><a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a>:       Copies a Lisp string into a foreign string. 
<li><a href="#with_002dforeign_002dstring">with-foreign-string</a>:          Allocates a foreign string with dynamic extent. 
<li><a href="#with_002dforeign_002dstrings">with-foreign-strings</a>:         Plural form of <code>with-foreign-string</code>. 
<li><a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>:   Similar to CL's with-output-to-string.

</li></ul>
<p>Variables

</p>
<ul class="menu">
<li><a href="#defcvar">defcvar</a>:                      Defines a C global variable. 
<li><a href="#get_002dvar_002dpointer">get-var-pointer</a>:              Returns a pointer to a defined global variable.

</li></ul>
<p>Functions

</p>
<ul class="menu">
<li><a href="#defcfun">defcfun</a>:                      Defines a foreign function. 
<li><a href="#foreign_002dfuncall">foreign-funcall</a>:              Performs a call to a foreign function. 
<li><a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>:      Performs a call through a foreign pointer. 
<li><a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>:     Converts a camelCase foreign name to/from a Lisp name. 
<li><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a>:   Converts a foreign name to a Lisp name. 
<li><a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>:    Converts a Lisp name to a foreign name. 
<li><a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>:   Converts an underscore_separated foreign name to/from a Lisp name.

</li></ul>
<p>Libraries

</p>
<ul class="menu">
<li><a href="#close_002dforeign_002dlibrary">close-foreign-library</a>:        Closes a foreign library. 
<li><a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a>:   Search path for Darwin frameworks. 
<li><a href="#define_002dforeign_002dlibrary">define-foreign-library</a>:       Explain how to load a foreign library. 
<li><a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>:   Search path for shared libraries. 
<li><a href="#load_002dforeign_002dlibrary">load-foreign-library</a>:         Load a foreign library. 
<li><a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a>:   Signalled on failure of its namesake. 
<!-- * reload-foreign-libraries::    Reload foreign libraries. -->
<li><a href="#use_002dforeign_002dlibrary">use-foreign-library</a>:          Load a foreign library when needed.

</li></ul>
<p>Callbacks

</p>
<ul class="menu">
<li><a href="#callback">callback</a>:                     Returns a pointer to a defined callback. 
<li><a href="#defcallback">defcallback</a>:                  Defines a Lisp callback. 
<li><a href="#get_002dcallback">get-callback</a>:                 Returns a pointer to a defined callback.

   </ul>

<!-- =================================================================== -->
<!-- CHAPTER: Introduction -->
<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Installation">Installation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p><acronym>CFFI</acronym> is the Common Foreign Function Interface for <acronym>ANSI</acronym>
Common Lisp systems.  By <dfn>foreign function</dfn> we mean a function
written in another programming language and having different data and
calling conventions than Common Lisp, namely, C.  <acronym>CFFI</acronym> allows you
to call foreign functions and access foreign variables, all without
leaving the Lisp image.

   <p>We consider this manual ever a work in progress.  If you have
difficulty with anything <acronym>CFFI</acronym>-specific presented in the manual,
please contact <a href="mailto:cffi-devel@common-lisp.net">the developers</a> with
details.

<h3 class="heading">Motivation</h3>

<p>See <a href="#Tutorial_002dComparison">What makes Lisp different</a>, for
an argument in favor of <acronym>FFI</acronym> in general.

   <p><acronym>CFFI</acronym>'s primary role in any image is to mediate between Lisp
developers and the widely varying <acronym>FFI</acronym>s present in the
various Lisp implementations it supports.  With <acronym>CFFI</acronym>, you can
define foreign function interfaces while still maintaining portability
between implementations.  It is not the first Common Lisp package with
this objective; however, it is meant to be a more malleable framework
than similar packages.

<h3 class="heading">Design Philosophy</h3>

     <ul>
<li>Pointers do not carry around type information. Instead, type
information is supplied when pointers are dereferenced.

     <li>A type safe pointer interface can be developed on top of an
untyped one.  It is difficult to do the opposite.

     <li>Functions are better than macros.  When a macro could be used
for performance, use a compiler-macro instead. 
</ul>

<!-- =================================================================== -->
<!-- CHAPTER: Installation -->
<div class="node">
<a name="Installation"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Implementation-Support">Implementation Support</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Installation</h2>

<p><acronym>CFFI</acronym> can be obtained through one of the following means available
through its <a href="http://common-lisp.net/project/cffi/">website</a>:

     <ul>
<li><a href="http://common-lisp.net/project/cffi/releases/?M=D">official release tarballs</a>

     <li><a href="http://common-lisp.net/gitweb?p=projects/cffi/cffi.git">git repository</a>

     <!-- snapshots have been disabled as of -->
     <!-- @item -->
     <!-- @uref{http://common-lisp.net/project/cffi/tarballs/?M=D,,nightly-generated -->
     <!-- snapshots} -->
   </ul>

   <p>In addition, you will need to obtain and install the following
dependencies:

     <ul>
<li><a href="http://common-lisp.net/project/babel/">Babel</a>, a charset
encoding/decoding library.

     <li><a href="http://common-lisp.net/project/alexandria/">Alexandria</a>, a
collection of portable public-domain utilities.

     <li><a href="http://www.cliki.net/trivial-features">trivial-features</a>, a
portability layer that ensures consistent <code>*features*</code> across
multiple Common Lisp implementations.

   </ul>

   <p>Furthermore, if you wish to run the testsuite,
<a href="http://www.cliki.net/rt">RT</a> is required.

   <p>You may find mechanisms such as
<a href="http://common-lisp.net/project/clbuild/">clbuild</a> (recommended)
or <a href="http://www.cliki.net/ASDF-Install">ASDF-Install</a> (not as
recommendable) helpful in getting and managing <acronym>CFFI</acronym> and its
dependencies.

<!-- =================================================================== -->
<!-- CHAPTER: Implementation Support -->
<div class="node">
<a name="Implementation-Support"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial">Tutorial</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Installation">Installation</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Implementation Support</h2>

<p><acronym>CFFI</acronym> supports various free and commercial Lisp implementations:
Allegro CL, Corman CL, <span class="sc">clisp</span>, <acronym>CMUCL</acronym>, <acronym>ECL</acronym>,
LispWorks, Clozure CL, <acronym>SBCL</acronym> and the Scieneer CL.

   <p>In general, you should work with the latest versions of each
implementation since those will usually be tested against recent
versions of CFFI more often and might include necessary features or
bug fixes. Reasonable patches for compatibility with earlier versions
are welcome nevertheless.

<h3 class="section">3.1 Limitations</h3>

<p>Some features are not supported in all implementations. 
<!-- TODO: describe these features here. -->
<!-- flat-namespace too -->

<h4 class="subheading">Allegro CL</h4>

     <ul>
<li>Does not support the <code>:long-long</code> type natively. 
<li>Unicode support is limited to the Basic Multilingual Plane (16-bit
code points). 
</ul>

<h4 class="subheading">CMUCL</h4>

     <ul>
<li>No Unicode support. (8-bit code points)
</ul>

<h4 class="subheading">Corman CL</h4>

     <ul>
<li>Does not support <code>foreign-funcall</code>. 
</ul>

<h4 class="subheading"><acronym>ECL</acronym></h4>

     <ul>
<li>On platforms where ECL's dynamic FFI is not supported (ie. when
<code>:dffi</code> is not present in <code>*features*</code>),
<code>cffi:load-foreign-library</code> does not work and you must use ECL's
own <code>ffi:load-foreign-library</code> with a constant string argument. 
<li>Does not support the <code>:long-long</code> type natively. 
<li>Unicode support is not enabled by default. 
</ul>

<h4 class="subheading">Lispworks</h4>

     <ul>
<li>Does not completely support the <code>:long-long</code> type natively in
32-bit platforms. 
<li>Unicode support is limited to the Basic Multilingual Plane (16-bit
code points). 
</ul>

<h4 class="subheading"><acronym>SBCL</acronym></h4>

     <ul>
<li>Not all platforms support callbacks.

</ul>

<!-- =================================================================== -->
<!-- CHAPTER: An Introduction to Foreign Interfaces and CFFI -->
<!-- This macro is merely a marker that I don't think I'll use after -->
<!-- all. -->
<!-- because I don't want to type this over and over -->
<!-- TeX puts spurious newlines in when you use the above macro -->
<!-- in @examples &c.  So it is expanded below in some places. -->
<div class="node">
<a name="Tutorial"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Wrapper-generators">Wrapper generators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Implementation-Support">Implementation Support</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 An Introduction to Foreign Interfaces and <acronym>CFFI</acronym></h2>

<!-- Above, I don't use the cffi macro because it breaks TeX. -->
<p><a name="index-tutorial_002c-_0040cffi_007b_007d-1"></a>Users of many popular languages bearing semantic similarity to Lisp,
such as Perl and Python, are accustomed to having access to popular C
libraries, such as <acronym>GTK</acronym>, by way of &ldquo;bindings&rdquo;.  In Lisp, we
do something similar, but take a fundamentally different approach. 
This tutorial first explains this difference, then explains how you
can use <acronym>CFFI</acronym>, a powerful system for calling out to C and C++ and
access C data from many Common Lisp implementations.

   <p><a name="index-foreign-functions-and-data-2"></a>The concept can be generalized to other languages; at the time of
writing, only <acronym>CFFI</acronym>'s C support is fairly complete, but C++
support is being worked on.  Therefore, we will interchangeably refer
to <dfn>foreign functions</dfn> and <dfn>foreign data</dfn>, and &ldquo;C functions&rdquo;
and &ldquo;C data&rdquo;.  At no time will the word &ldquo;foreign&rdquo; carry its usual,
non-programming meaning.

   <p>This tutorial expects you to have a working understanding of both
Common Lisp and C, including the Common Lisp macro system.

<ul class="menu">
<li><a accesskey="1" href="#Tutorial_002dComparison">Tutorial-Comparison</a>:          Why FFI? 
<li><a accesskey="2" href="#Tutorial_002dGetting-a-URL">Tutorial-Getting a URL</a>:       An FFI use case. 
<li><a accesskey="3" href="#Tutorial_002dLoading">Tutorial-Loading</a>:             Load libcurl.so. 
<li><a accesskey="4" href="#Tutorial_002dInitializing">Tutorial-Initializing</a>:        Call a function in libcurl.so. 
<li><a accesskey="5" href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a>:         An advanced libcurl function. 
<li><a accesskey="6" href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a>:         Why breaking it is necessary. 
<li><a accesskey="7" href="#Tutorial_002dLisp-easy_005fsetopt">Tutorial-Lisp easy_setopt</a>:    Semi-Lispy option interface. 
<li><a accesskey="8" href="#Tutorial_002dMemory">Tutorial-Memory</a>:              In C, you collect the garbage. 
<li><a accesskey="9" href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a>:           Make useful C function pointers. 
<li><a href="#Tutorial_002dCompletion">Tutorial-Completion</a>:          Minimal get-url functionality. 
<li><a href="#Tutorial_002dTypes">Tutorial-Types</a>:               Defining new foreign types. 
<li><a href="#Tutorial_002dConclusion">Tutorial-Conclusion</a>:          What's next? 
</ul>

<div class="node">
<a name="Tutorial-Comparison"></a>
<a name="Tutorial_002dComparison"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dGetting-a-URL">Tutorial-Getting a URL</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial">Tutorial</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.1 What makes Lisp different</h3>

<p>The following sums up how bindings to foreign libraries are usually
implemented in other languages, then in Common Lisp:

     <dl>
<dt>Perl, Python, Java, other one-implementation languages<dd><a name="index-g_t_0040acronym_007bSWIG_007d-3"></a><a name="index-Perl-4"></a><a name="index-Python-5"></a>Bindings are implemented as shared objects written in C.  In some
cases, the C code is generated by a tool, such as <acronym>SWIG</acronym>, but
the result is the same: a new C library that manually translates
between the language implementation's objects, such as <code>PyObject</code>
in Python, and whatever C object is called for, often using C
functions provided by the implementation.  It also translates between
the calling conventions of the language and C.

     <br><dt>Common Lisp<dd><a name="index-g_t_0040acronym_007bSLIME_007d-6"></a>Bindings are written in Lisp.  They can be created at-will by Lisp
programs.  Lisp programmers can write new bindings and add them to the
image, using a listener such as <acronym>SLIME</acronym>, as easily as with
regular Lisp definitions.  The only foreign library to load is the one
being wrapped&mdash;the one with the pure C interface; no C or other
non-Lisp compilation is required. 
</dl>

   <p><a name="index-advantages-of-_0040acronym_007bFFI_007d-7"></a><a name="index-benefits-of-_0040acronym_007bFFI_007d-8"></a>We believe the advantages of the Common Lisp approach far outweigh any
disadvantages.  Incremental development with a listener can be as
productive for C binding development as it is with other Lisp
development.  Keeping it &ldquo;in the [Lisp] family&rdquo;, as it were, makes
it much easier for you and other Lisp programmers to load and use the
bindings.  Common Lisp implementations such as <acronym>CMUCL</acronym>, freed
from having to provide a C interface to their own objects, are thus
freed to be implemented in another language (as <acronym>CMUCL</acronym> is)
while still allowing programmers to call foreign functions.

   <p><a name="index-minimal-bindings-9"></a>Perhaps the greatest advantage is that using an <acronym>FFI</acronym> doesn't
obligate you to become a professional binding developer.  Writers of
bindings for other languages usually end up maintaining or failing to
maintain complete bindings to the foreign library.  Using an
<acronym>FFI</acronym>, however, means if you only need one or two functions,
you can write bindings for only those functions, and be assured that
you can just as easily add to the bindings if need be.

   <p><a name="index-C-abstractions-10"></a><a name="index-abstractions-in-C-11"></a>The removal of the C compiler, or C interpretation of any kind,
creates the main disadvantage: some of C's &ldquo;abstractions&rdquo; are not
available, violating information encapsulation.  For example,
<code>struct</code>s that must be passed on the stack, or used as return
values, without corresponding functional abstractions to create and
manage the <code>struct</code>s, must be declared explicitly in Lisp.  This
is fine for structs whose contents are &ldquo;public&rdquo;, but is not so
pleasant when a struct is supposed to be &ldquo;opaque&rdquo; by convention,
even though it is not so defined.<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>

   <p>Without an abstraction to create the struct, Lisp needs to be able to
lay out the struct in memory, so must know its internal details.

   <p><a name="index-workaround-for-C-12"></a>In these cases, you can create a minimal C library to provide the
missing abstractions, without destroying all the advantages of the
Common Lisp approach discussed above.  In the case of <code>struct</code>s,
you can write simple, pure C functions that tell you how many bytes a
struct requires or allocate new structs, read and write fields of the
struct, or whatever operations are supposed to be
public.<a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

   <blockquote>
<strong>Implementor's note:</strong> <em>cffi-grovel, a project not yet part of <acronym>CFFI</acronym>, automates
this and other processes.</em>
</blockquote>

   <p>Another disadvantage appears when you would rather use the foreign
language than Lisp.  However, someone who prefers C to Lisp is not a
likely candidate for developing a Lisp interface to a C library.

<div class="node">
<a name="Tutorial-Getting-a-URL"></a>
<a name="Tutorial_002dGetting-a-URL"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dLoading">Tutorial-Loading</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dComparison">Tutorial-Comparison</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.2 Getting a <acronym>URL</acronym></h3>

<p><a name="index-c_0040acronym_007bURL_007d-13"></a>The widely available <code>libcurl</code> is a library for downloading files
over protocols like <acronym>HTTP</acronym>.  We will use <code>libcurl</code> with
<acronym>CFFI</acronym> to download a web page.

   <p>Please note that there are many other ways to download files from the
web, not least the <span class="sc">cl-curl</span> project to provide bindings to
<code>libcurl</code> via a similar <acronym>FFI</acronym>.<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a>

   <p><a href="http://curl.haxx.se/libcurl/c/libcurl-tutorial.html">libcurl-tutorial(3)</a>
is a tutorial for <code>libcurl</code> programming in C.  We will follow
that to develop a binding to download a file.  We will also use
<samp><span class="file">curl.h</span></samp>, <samp><span class="file">easy.h</span></samp>, and the <samp><span class="command">man</span></samp> pages for the
<code>libcurl</code> function, all available in the &lsquo;<samp><span class="samp">curl-dev</span></samp>&rsquo; package
or equivalent for your system, or in the c<acronym>URL</acronym> source code
package.  If you have the development package, the headers should be
installed in <samp><span class="file">/usr/include/curl/</span></samp>, and the <samp><span class="command">man</span></samp> pages
may be accessed through your favorite <samp><span class="command">man</span></samp> facility.

<div class="node">
<a name="Tutorial-Loading"></a>
<a name="Tutorial_002dLoading"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dInitializing">Tutorial-Initializing</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dGetting-a-URL">Tutorial-Getting a URL</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.3 Loading foreign libraries</h3>

<p><a name="index-loading-_0040cffi_007b_007d-14"></a><a name="index-requiring-_0040cffi_007b_007d-15"></a>First of all, we will create a package to work in.  You can save these
forms in a file, or just send them to the listener as they are.  If
creating bindings for an <acronym>ASDF</acronym> package of yours, you will
want to add <code>:cffi</code> to the <code>:depends-on</code> list in your
<samp><span class="file">.asd</span></samp> file.  Otherwise, just use the <code>asdf:oos</code> function to
load <acronym>CFFI</acronym>.

<!-- Initialization -->
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">asdf:oos 'asdf:load-op <span class="keyword">:cffi</span></span>)</span>
   
  <span class="comment">;;; Nothing special about the "CFFI-USER" package.  We're just
  </span><span class="comment">;;; using it as a substitute for your own CL package.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">:cffi-user</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span> <span class="keyword">:common-lisp</span> <span class="keyword">:cffi</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg">in-package <span class="keyword">:cffi-user</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-library</span></i> libcurl
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:unix</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:or</span> <span class="string">"libcurl.so.3"</span> <span class="string">"libcurl.so"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">t <span class="paren3">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"libcurl"</span></span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg">use-foreign-library libcurl</span>)</span>
</pre>
   <p><a name="index-foreign-library-load-16"></a><a name="index-library_002c-foreign-17"></a>Using <code>define-foreign-library</code> and <code>use-foreign-library</code>, we
have loaded <code>libcurl</code> into Lisp, much as the linker does when you
start a C program, or <code>common-lisp:load</code> does with a Lisp source
file or <acronym>FASL</acronym> file.  We special-cased for <span class="sc">unix</span> machines
to always load a particular version, the one this tutorial was tested
with; for those who don't care, the <code>define-foreign-library</code>
clause <code>(t (:default "libcurl"))</code> should be satisfactory, and
will adapt to various operating systems.

<div class="node">
<a name="Tutorial-Initializing"></a>
<a name="Tutorial_002dInitializing"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dLoading">Tutorial-Loading</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.4 Initializing <code>libcurl</code></h3>

<p><a name="index-function-definition-18"></a>After the introductory matter, the tutorial goes on to present the
first function you should use.

<pre class="example">  CURLcode curl_global_init(long flags);
</pre>
   <p class="noindent">Let's pick this apart into appropriate Lisp code:

<!-- First CURLcode -->
<pre class="lisp">  <span class="comment">;;; A CURLcode is the universal error code.  curl/curl.h says
  </span><span class="comment">;;; no return code will ever be removed, and new ones will be
  </span><span class="comment">;;; added to the end.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> curl-code <span class="keyword">:int</span></span>)</span>
   
  <span class="comment">;;; Initialize libcurl with FLAGS.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_global_init"</span> curl-code
    <span class="paren2">(<span class="lisp-bg">flags <span class="keyword">:long</span></span>)</span></span>)</span>
</pre>
   <blockquote>
<strong>Implementor's note:</strong> <em>By default, CFFI assumes the UNIX viewpoint that there is one
C symbol namespace, containing all symbols in all loaded objects. 
This is not so on Windows and Darwin, but we emulate UNIX's behaviour
there.  <a href="#defcfun">defcfun</a> for more details.</em>
</blockquote>

   <p>Note the parallels with the original C declaration.  We've defined
<code>curl-code</code> as a wrapping type for <code>:int</code>; right now, it
only marks it as special, but later we will do something more
interesting with it.  The point is that we don't have to do it yet.

   <p><a name="index-calling-foreign-functions-19"></a>Looking at <samp><span class="file">curl.h</span></samp>, <code>CURL_GLOBAL_NOTHING</code>, a possible value
for <code>flags</code> above, is defined as &lsquo;<samp><span class="samp">0</span></samp>&rsquo;.  So we can now call
the function:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (curl-global-init 0)
  =&gt; 0
</pre>
   <p><a name="index-looks-like-it-worked-20"></a>Looking at <samp><span class="file">curl.h</span></samp> again, <code>0</code> means <code>CURLE_OK</code>, so it
looks like the call succeeded.  Note that <acronym>CFFI</acronym> converted the
function name to a Lisp-friendly name.  You can specify your own name
if you want; use <code>("curl_global_init" </code><var>your-name-here</var><code>)</code> as
the <var>name</var> argument to <code>defcfun</code>.

   <p>The tutorial goes on to have us allocate a handle.  For good measure,
we should also include the deallocator.  Let's look at these
functions:

<pre class="example">  CURL *curl_easy_init( );
  void curl_easy_cleanup(CURL *handle);
</pre>
   <p>Advanced users may want to define special pointer types; we will
explore this possibility later.  For now, just treat every pointer as
the same:

<!-- curl_easy handles -->
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_init"</span> <span class="keyword">:pointer</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_cleanup"</span> <span class="keyword">:void</span>
    <span class="paren2">(<span class="lisp-bg">easy-handle <span class="keyword">:pointer</span></span>)</span></span>)</span>
</pre>
   <p>Now we can continue with the tutorial:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (defparameter *easy-handle* (curl-easy-init))
  =&gt; *EASY-HANDLE*
  <span class="sc">cffi-user&gt;</span> *easy-handle*
  =&gt; #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
</pre>
   <p><a name="index-pointers-in-Lisp-21"></a>Note the print representation of a pointer.  It changes depending on
what Lisp you are using, but that doesn't make any difference to
<acronym>CFFI</acronym>.

<div class="node">
<a name="Tutorial-easy_setopt"></a>
<a name="Tutorial_002deasy_005fsetopt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dInitializing">Tutorial-Initializing</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.5 Setting download options</h3>

<p>The <code>libcurl</code> tutorial says we'll want to set many options before
performing any download actions.  This is done through
<code>curl_easy_setopt</code>:

<!-- That is literally ..., not an ellipsis. -->
<pre class="example">  CURLcode curl_easy_setopt(CURL *curl, CURLoption option, ...);
</pre>
   <p><a name="index-varargs-22"></a><a name="index-foreign-arguments-23"></a>We've introduced a new twist: variable arguments.  There is no obvious
translation to the <code>defcfun</code> form, particularly as there are four
possible argument types.  Because of the way C works, we could define
four wrappers around <code>curl_easy_setopt</code>, one for each type; in
this case, however, we'll use the general-purpose macro
<code>foreign-funcall</code> to call this function.

   <p><a name="index-enumeration_002c-C-24"></a>To make things easier on ourselves, we'll create an enumeration of the
kinds of options we want to set.  The <code>enum CURLoption</code> isn't the
most straightforward, but reading the <code>CINIT</code> C macro definition
should be enlightening.

<!-- CURLoption enumeration -->
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-options</span></i> <span class="paren2">(<span class="lisp-bg">name type-offsets &amp;rest enum-args</span>)</span>
    <span class="string">"As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:
   
      (NAME TYPE NUMBER)
   
  Where the arguments are as they are with the CINIT macro defined
  in curl.h, except NAME is a keyword.
   
  TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
  defined by the CURLOPTTYPE_LONG et al constants in curl.h."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">flet</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">enumerated-value <span class="paren5">(<span class="lisp-bg">type offset</span>)</span>
             <span class="paren5">(<span class="lisp-bg">+ <span class="paren6">(<span class="lisp-bg">getf type-offsets type</span>)</span> offset</span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
         <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> ,name
           ,@<span class="paren5">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for <span class="paren6">(<span class="lisp-bg">name type number</span>)</span> in enum-args
                collect <span class="paren6">(<span class="lisp-bg">list name <span class="paren1">(<span class="lisp-bg">enumerated-value type number</span>)</span></span>)</span></span>)</span></span>)</span>
         ',name</span>)</span></span>)</span></span>)</span>                ;for REPL users' sanity
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-curl-options</span></i> curl-option
      <span class="paren2">(<span class="lisp-bg">long 0 objectpoint 10000 functionpoint 20000 off-t 30000</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:noprogress</span> long 43</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nosignal</span> long 99</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> objectpoint 10</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:url</span> objectpoint 2</span>)</span></span>)</span>
</pre>
   <p>With some well-placed Emacs <code>query-replace-regexp</code>s, you could
probably similarly define the entire <code>CURLoption</code> enumeration.  I
have selected to transcribe a few that we will use in this tutorial.

   <p>If you're having trouble following the macrology, just macroexpand the
<code>curl-option</code> definition, or see the following macroexpansion,
conveniently downcased and reformatted:

<!-- DEFINE-CURL-OPTIONS macroexpansion -->
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> curl-option
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:noprogress</span> 43</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:nosignal</span> 99</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> 10010</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:url</span> 10002</span>)</span></span>)</span>
    'curl-option</span>)</span>
</pre>
   <p class="noindent">That seems more than reasonable.  You may notice that we only use the
<var>type</var> to compute the real enumeration offset; we will also need
the type information later.

   <p>First, however, let's make sure a simple call to the foreign function
works:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (foreign-funcall "curl_easy_setopt"
                 :pointer *easy-handle*
                 curl-option :nosignal :long 1 curl-code)
  =&gt; 0
</pre>
   <p><code>foreign-funcall</code>, despite its surface simplicity, can be used to
call any C function.  Its first argument is a string, naming the
function to be called.  Next, for each argument, we pass the name of
the C type, which is the same as in <code>defcfun</code>, followed by a Lisp
object representing the data to be passed as the argument.  The final
argument is the return type, for which we use the <code>curl-code</code>
type defined earlier.

   <p><code>defcfun</code> just puts a convenient fa&ccedil;ade on
<code>foreign-funcall</code>.<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a>  Our earlier call to
<code>curl-global-init</code> could have been written as follows:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (foreign-funcall "curl_global_init" :long 0
                              curl-code)
  =&gt; 0
</pre>
   <p>Before we continue, we will take a look at what <acronym>CFFI</acronym> can and can't
do, and why this is so.

<div class="node">
<a name="Tutorial-Abstraction"></a>
<a name="Tutorial_002dAbstraction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dLisp-easy_005fsetopt">Tutorial-Lisp easy_setopt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.6 Breaking the abstraction</h3>

<p><a name="index-breaking-the-abstraction-25"></a><a name="index-abstraction-breaking-26"></a>In <a href="#Tutorial_002dComparison">What makes Lisp different</a>, we mentioned
that writing an <acronym>FFI</acronym> sometimes requires depending on
information not provided as part of the interface.  The easy option
<code>CURLOPT_WRITEDATA</code>, which we will not provide as part of the
Lisp interface, illustrates this issue.

   <p>Strictly speaking, the <code>curl-option</code> enumeration is not
necessary; we could have used <code>:int 99</code> instead of
<code>curl-option :nosignal</code> in our call to <code>curl_easy_setopt</code>
above.  We defined it anyway, in part to hide the fact that we are
breaking the abstraction that the C <code>enum</code> provides.  If the
c<acronym>URL</acronym> developers decide to change those numbers later, we
must change the Lisp enumeration, because enumeration values are not
provided in the compiled C library, <code>libcurl.so.3</code>.

   <p><acronym>CFFI</acronym> works because the most useful things in C libraries &mdash;
non-static functions and non-static variables &mdash; are included
accessibly in <code>libcurl.so.3</code>.  A C compiler that violated this
would be considered a worthless compiler.

   <p>The other thing <code>define-curl-options</code> does is give the &ldquo;type&rdquo;
of the third argument passed to <code>curl_easy_setopt</code>.  Using this
information, we can tell that the <code>:nosignal</code> option should
accept a long integer argument.  We can implicitly assume <code>t</code>
== 1 and <code>nil</code> == 0, as it is in C, which takes care
of the fact that <code>CURLOPT_NOSIGNAL</code> is really asking for a
boolean.

   <p>The &ldquo;type&rdquo; of <code>CURLOPT_WRITEDATA</code> is <code>objectpoint</code>. 
However, it is really looking for a <code>FILE*</code>. 
<code>CURLOPT_ERRORBUFFER</code> is looking for a <code>char*</code>, so there is
no obvious <acronym>CFFI</acronym> type but <code>:pointer</code>.

   <p>The first thing to note is that nowhere in the C interface includes
this information; it can only be found in the manual.  We could
disjoin these clearly different types ourselves, by splitting
<code>objectpoint</code> into <code>filepoint</code> and <code>charpoint</code>, but we
are still breaking the abstraction, because we have to augment the
entire enumeration form with this additional
information.<a rel="footnote" href="#fn-5" name="fnd-5"><sup>5</sup></a>

   <p><a name="index-streams-and-C-27"></a><a name="index-g_t_0040sc_007bfile_007d_002a-and-streams-28"></a>The second is that the <code>CURLOPT_WRITEDATA</code> argument is completely
incompatible with the desired Lisp data, a
stream.<a rel="footnote" href="#fn-6" name="fnd-6"><sup>6</sup></a>  It is probably acceptable if we are controlling every file
we might want to use as this argument, in which case we can just call
the foreign function <code>fopen</code>.  Regardless, though, we can't write
to arbitrary streams, which is exactly what we want to do for this
application.

   <p>Finally, note that the <code>curl_easy_setopt</code> interface itself is a
hack, intended to work around some of the drawbacks of C.  The
definition of <code>Curl_setopt</code>, while long, is far less cluttered
than the equivalent disjoint-function set would be; in addition,
setting a new option in an old <code>libcurl</code> can generate a run-time
error rather than breaking the compile.  Lisp can just as concisely
generate functions as compare values, and the &ldquo;undefined function&rdquo;
error is just as useful as any explicit error we could define here
might be.

<div class="node">
<a name="Tutorial-Lisp-easy_setopt"></a>
<a name="Tutorial_002dLisp-easy_005fsetopt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dMemory">Tutorial-Memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.7 Option functions in Lisp</h3>

<p>We could use <code>foreign-funcall</code> directly every time we wanted to
call <code>curl_easy_setopt</code>.  However, we can encapsulate some of the
necessary information with the following.

<pre class="lisp">  <span class="comment">;;; We will use this type later in a more creative way.  For
  </span><span class="comment">;;; now, just consider it a marker that this isn't just any
  </span><span class="comment">;;; pointer.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> easy-handle <span class="keyword">:pointer</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> curl-easy-setopt <span class="paren2">(<span class="lisp-bg">easy-handle enumerated-name
                              value-type new-value</span>)</span>
    <span class="string">"Call `curl_easy_setopt' on EASY-HANDLE, using ENUMERATED-NAME
  as the OPTION.  VALUE-TYPE is the CFFI foreign type of the third
  argument, and NEW-VALUE is the Lisp data to be translated to the
  third argument.  VALUE-TYPE is not evaluated."</span>
    `<span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"curl_easy_setopt"</span> easy-handle ,easy-handle
                      curl-option ,enumerated-name
                      ,value-type ,new-value curl-code</span>)</span></span>)</span>
</pre>
   <p>Now we define a function for each kind of argument that encodes the
correct <code>value-type</code> in the above.  This can be done reasonably
in the <code>define-curl-options</code> macroexpansion; after all, that is
where the different options are listed!

   <p><a name="index-Lispy-C-functions-29"></a>We could make <code>cl:defun</code> forms in the expansion that simply call
<code>curl-easy-setopt</code>; however, it is probably easier and clearer to
use <code>defcfun</code>.  <code>define-curl-options</code> was becoming unwieldy,
so I defined some helpers in this new definition.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> curry-curl-option-setter <span class="paren2">(<span class="lisp-bg">function-name option-keyword</span>)</span>
    <span class="string">"Wrap the function named by FUNCTION-NAME with a version that
  curries the second argument as OPTION-KEYWORD.
   
  This function is intended for use in DEFINE-CURL-OPTION-SETTER."</span>
    <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">symbol-function function-name</span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">c-function <span class="paren6">(<span class="lisp-bg">symbol-function function-name</span>)</span></span>)</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="lisp-bg">easy-handle new-value</span>)</span>
                <span class="paren5">(<span class="lisp-bg">funcall c-function easy-handle option-keyword
                         new-value</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-option-setter</span></i> <span class="paren2">(<span class="lisp-bg">name option-type
                                       option-value foreign-type</span>)</span>
    <span class="string">"Define (with DEFCFUN) a function NAME that calls
  curl_easy_setopt.  OPTION-TYPE and OPTION-VALUE are the CFFI
  foreign type and value to be passed as the second argument to
  easy_setopt, and FOREIGN-TYPE is the CFFI foreign type to be used
  for the resultant function's third argument.
   
  This macro is intended for use in DEFINE-CURL-OPTIONS."</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
       <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren4">(<span class="lisp-bg"><span class="string">"curl_easy_setopt"</span> ,name</span>)</span> curl-code
         <span class="paren4">(<span class="lisp-bg">easy-handle easy-handle</span>)</span>
         <span class="paren4">(<span class="lisp-bg">option ,option-type</span>)</span>
         <span class="paren4">(<span class="lisp-bg">new-value ,foreign-type</span>)</span></span>)</span>
       <span class="paren3">(<span class="lisp-bg">curry-curl-option-setter ',name ',option-value</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmacro</span></i> <i><span class="symbol">define-curl-options</span></i> <span class="paren2">(<span class="lisp-bg">type-name type-offsets &amp;rest enum-args</span>)</span>
    <span class="string">"As with CFFI:DEFCENUM, except each of ENUM-ARGS is as follows:
   
      (NAME TYPE NUMBER)
   
  Where the arguments are as they are with the CINIT macro defined
  in curl.h, except NAME is a keyword.
   
  TYPE-OFFSETS is a plist of TYPEs to their integer offsets, as
  defined by the CURLOPTTYPE_LONG et al constants in curl.h.
   
  Also, define functions for each option named
  set-`TYPE-NAME'-`OPTION-NAME', where OPTION-NAME is the NAME from
  the above destructuring."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">flet</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">enumerated-value <span class="paren5">(<span class="lisp-bg">type offset</span>)</span>
             <span class="paren5">(<span class="lisp-bg">+ <span class="paren6">(<span class="lisp-bg">getf type-offsets type</span>)</span> offset</span>)</span></span>)</span>
           <span class="comment">;; map PROCEDURE, destructuring each of ENUM-ARGS
  </span>         <span class="paren4">(<span class="lisp-bg">map-enum-args <span class="paren5">(<span class="lisp-bg">procedure</span>)</span>
             <span class="paren5">(<span class="lisp-bg">mapcar <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren1">(<span class="lisp-bg">arg</span>)</span> <span class="paren1">(<span class="lisp-bg">apply procedure arg</span>)</span></span>)</span> enum-args</span>)</span></span>)</span>
           <span class="comment">;; build a name like SET-CURL-OPTION-NOSIGNAL
  </span>         <span class="paren4">(<span class="lisp-bg">make-setter-name <span class="paren5">(<span class="lisp-bg">option-name</span>)</span>
             <span class="paren5">(<span class="lisp-bg">intern <span class="paren6">(<span class="lisp-bg">concatenate
                      'string <span class="string">"SET-"</span> <span class="paren1">(<span class="lisp-bg">symbol-name type-name</span>)</span>
                      <span class="string">"-"</span> <span class="paren1">(<span class="lisp-bg">symbol-name option-name</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
         <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> ,type-name
           ,@<span class="paren5">(<span class="lisp-bg">map-enum-args
              <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren1">(<span class="lisp-bg">name type number</span>)</span>
                <span class="paren1">(<span class="lisp-bg">list name <span class="paren2">(<span class="lisp-bg">enumerated-value type number</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
         ,@<span class="paren4">(<span class="lisp-bg">map-enum-args
            <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren6">(<span class="lisp-bg">name type number</span>)</span>
              <span class="paren6">(<span class="lisp-bg">declare <span class="paren1">(<span class="lisp-bg">ignore number</span>)</span></span>)</span>
              `<span class="paren6">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> ,<span class="paren1">(<span class="lisp-bg">make-setter-name name</span>)</span>
                 ,type-name ,name ,<span class="paren1">(<span class="lisp-bg">ecase type
                                     <span class="paren2">(<span class="lisp-bg">long <span class="keyword">:long</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">objectpoint <span class="keyword">:pointer</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">functionpoint <span class="keyword">:pointer</span></span>)</span>
                                     <span class="paren2">(<span class="lisp-bg">off-t <span class="keyword">:long</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
         ',type-name</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">Macroexpanding our <code>define-curl-options</code> form once more, we
see something different:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> curl-option
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:noprogress</span> 43</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:nosignal</span> 99</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> 10010</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><span class="keyword">:url</span> 10002</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-noprogress
      curl-option <span class="keyword">:noprogress</span> <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-nosignal
      curl-option <span class="keyword">:nosignal</span> <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-errorbuffer
      curl-option <span class="keyword">:errorbuffer</span> <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">define-curl-option-setter</span></i> set-curl-option-url
      curl-option <span class="keyword">:url</span> <span class="keyword">:pointer</span></span>)</span>
    'curl-option</span>)</span>
</pre>
   <p class="noindent">Macroexpanding one of the new <code>define-curl-option-setter</code>
forms yields the following:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren3">(<span class="lisp-bg"><span class="string">"curl_easy_setopt"</span> set-curl-option-nosignal</span>)</span> curl-code
      <span class="paren3">(<span class="lisp-bg">easy-handle easy-handle</span>)</span>
      <span class="paren3">(<span class="lisp-bg">option curl-option</span>)</span>
      <span class="paren3">(<span class="lisp-bg">new-value <span class="keyword">:long</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">curry-curl-option-setter 'set-curl-option-nosignal '<span class="keyword">:nosignal</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">Finally, let's try this out:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (set-curl-option-nosignal *easy-handle* 1)
  =&gt; 0
</pre>
   <p class="noindent">Looks like it works just as well.  This interface is now reasonably
high-level to wash out some of the ugliness of the thinnest possible
<code>curl_easy_setopt</code> <acronym>FFI</acronym>, without obscuring the remaining
C bookkeeping details we will explore.

<div class="node">
<a name="Tutorial-Memory"></a>
<a name="Tutorial_002dMemory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dLisp-easy_005fsetopt">Tutorial-Lisp easy_setopt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.8 Memory management</h3>

<p>According to the documentation for <code>curl_easy_setopt</code>, the type
of the third argument when <var>option</var> is <code>CURLOPT_ERRORBUFFER</code>
is <code>char*</code>.  Above, we've defined
<code>set-curl-option-errorbuffer</code> to accept a <code>:pointer</code> as the
new option value.  However, there is a <acronym>CFFI</acronym> type <code>:string</code>,
which translates Lisp strings to C strings when passed as arguments to
foreign function calls.  Why not, then, use <code>:string</code> as the
<acronym>CFFI</acronym> type of the third argument?  There are two reasons, both
related to the necessity of breaking abstraction described in
<a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>.

   <p>The first reason also applies to <code>CURLOPT_URL</code>, which we will use
to illustrate the point.  Assuming we have changed the type of the
third argument underlying <code>set-curl-option-url</code> to
<code>:string</code>, look at these two equivalent forms.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">set-curl-option-url <span class="special">*easy-handle*</span> <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>
   
  == <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">url <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>
       <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"curl_easy_setopt"</span> easy-handle <span class="special">*easy-handle*</span>
                        curl-option <span class="keyword">:url</span> <span class="keyword">:pointer</span> url curl-code</span>)</span></span>)</span>
</pre>
   <p class="noindent">The latter, in fact, is mostly equivalent to what a foreign function
call's macroexpansion actually does.  As you can see, the Lisp string
<code>"http://www.cliki.net/CFFI"</code> is copied into a <code>char</code> array and
null-terminated; the pointer to beginning of this array, now a C
string, is passed as a <acronym>CFFI</acronym> <code>:pointer</code> to the foreign
function.

   <p><a name="index-dynamic-extent-30"></a><a name="index-foreign-values-with-dynamic-extent-31"></a>Unfortunately, the C abstraction has failed us, and we must break it. 
While <code>:string</code> works well for many <code>char*</code> arguments, it
does not for cases like this.  As the <code>curl_easy_setopt</code>
documentation explains, &ldquo;The string must remain present until curl no
longer needs it, as it doesn't copy the string.&rdquo;  The C string
created by <code>with-foreign-string</code>, however, only has dynamic
extent: it is &ldquo;deallocated&rdquo; when the body (above containing the
<code>foreign-funcall</code> form) exits.

   <p><a name="index-premature-deallocation-32"></a>If we are supposed to keep the C string around, but it goes away, what
happens when some <code>libcurl</code> function tries to access the
<acronym>URL</acronym> string?  We have reentered the dreaded world of C
&ldquo;undefined behavior&rdquo;.  In some Lisps, it will probably get a chunk
of the Lisp/C stack.  You may segfault.  You may get some random piece
of other data from the heap.  Maybe, in a world where &ldquo;dynamic
extent&rdquo; is defined to be &ldquo;infinite extent&rdquo;, everything will turn
out fine.  Regardless, results are likely to be almost universally
unpleasant.<a rel="footnote" href="#fn-7" name="fnd-7"><sup>7</sup></a>

   <p>Returning to the current <code>set-curl-option-url</code> interface, here is
what we must do:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg">easy-handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">unwind-protect</span></i>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren4">(<span class="lisp-bg">url <span class="string">"http://www.cliki.net/CFFI"</span></span>)</span>
        <span class="paren4">(<span class="lisp-bg">setf easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span>
        <span class="paren4">(<span class="lisp-bg">set-curl-option-url easy-handle url</span>)</span>
        <span class="comment">#|do more with the easy-handle, like actually get the URL|#</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">when easy-handle
        <span class="paren4">(<span class="lisp-bg">curl-easy-cleanup easy-handle</span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <!-- old comment to luis: I go on to say that this isn't obviously -->
<!-- extensible to new option settings that require C strings to stick -->
<!-- around, as it would involve re-evaluating the unwind-protect form -->
<!-- with more dynamic memory allocation.  So I plan to show how to -->
<!-- write something similar to ObjC's NSAutoreleasePool, to be managed -->
<!-- with a simple unwind-protect form. -->
<p class="noindent">That is fine for the single string defined here, but for every string
option we want to pass, we have to surround the body of
<code>with-foreign-string</code> with another <code>with-foreign-string</code>
wrapper, or else do some extremely error-prone pointer manipulation
and size calculation in advance.  We could alleviate some of the pain
with a recursively expanding macro, but this would not remove the need
to modify the block every time we want to add an option, anathema as
it is to a modular interface.

   <p>Before modifying the code to account for this case, consider the other
reason we can't simply use <code>:string</code> as the foreign type.  In C,
a <code>char *</code> is a <code>char *</code>, not necessarily a string.  The
option <code>CURLOPT_ERRORBUFFER</code> accepts a <code>char *</code>, but does
not expect anything about the data there.  However, it does expect
that some <code>libcurl</code> function we call later can write a C string
of up to 255 characters there.  We, the callers of the function, are
expected to read the C string at a later time, exactly the opposite of
what <code>:string</code> implies.

   <p>With the semantics for an input string in mind &mdash; namely, that the
string should be kept around until we <code>curl_easy_cleanup</code> the
easy handle &mdash; we are ready to extend the Lisp interface:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defvar</span></i> <span class="special">*easy-handle-cstrings*</span> <span class="paren2">(<span class="lisp-bg">make-hash-table</span>)</span>
    <span class="string">"Hashtable of easy handles to lists of C strings that may be
  safely freed after the handle is freed."</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> make-easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="string">"Answer a new CURL easy interface handle, to which the lifetime
  of C strings may be tied.  See `add-curl-handle-cstring'."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-cstrings*</span></span>)</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span></span>)</span>
      easy-handle</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg">curl-easy-cleanup handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg">mapc #'foreign-string-free
          <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> add-curl-handle-cstring <span class="paren2">(<span class="lisp-bg">handle cstring</span>)</span>
    <span class="string">"Add CSTRING to be freed when HANDLE is, answering CSTRING."</span>
    <span class="paren2">(<span class="lisp-bg">car <span class="paren3">(<span class="lisp-bg">push cstring <span class="paren4">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">Here we have redefined the interface to create and free handles, to
associate a list of allocated C strings with each handle while it
exists.  The strategy of using different function names to wrap around
simple foreign functions is more common than the solution implemented
earlier with <code>curry-curl-option-setter</code>, which was to modify the
function name's function slot.<a rel="footnote" href="#fn-8" name="fnd-8"><sup>8</sup></a>

   <p>Incidentally, the next step is to redefine
<code>curry-curl-option-setter</code> to allocate C strings for the
appropriate length of time, given a Lisp string as the
<code>new-value</code> argument:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> curry-curl-option-setter <span class="paren2">(<span class="lisp-bg">function-name option-keyword</span>)</span>
    <span class="string">"Wrap the function named by FUNCTION-NAME with a version that
  curries the second argument as OPTION-KEYWORD.
   
  This function is intended for use in DEFINE-CURL-OPTION-SETTER."</span>
    <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">symbol-function function-name</span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">c-function <span class="paren6">(<span class="lisp-bg">symbol-function function-name</span>)</span></span>)</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren5">(<span class="lisp-bg">easy-handle new-value</span>)</span>
                <span class="paren5">(<span class="lisp-bg">funcall c-function easy-handle option-keyword
                         <span class="paren6">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="lisp-bg">stringp new-value</span>)</span>
                           <span class="paren1">(<span class="lisp-bg">add-curl-handle-cstring
                            easy-handle
                            <span class="paren2">(<span class="lisp-bg">foreign-string-alloc new-value</span>)</span></span>)</span>
                           new-value</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">A quick analysis of the code shows that you need only reevaluate the
<code>curl-option</code> enumeration definition to take advantage of these
new semantics.  Now, for good measure, let's reallocate the handle
with the new functions we just defined, and set its <acronym>URL</acronym>:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (curl-easy-cleanup *easy-handle*)
  =&gt; NIL
  <span class="sc">cffi-user&gt;</span> (setf *easy-handle* (make-easy-handle))
  =&gt; #&lt;FOREIGN-ADDRESS #x09844EE0&gt;
  <span class="sc">cffi-user&gt;</span> (set-curl-option-nosignal *easy-handle* 1)
  =&gt; 0
  <span class="sc">cffi-user&gt;</span> (set-curl-option-url *easy-handle*
                                  "http://www.cliki.net/CFFI")
  =&gt; 0
</pre>
   <p><a name="index-strings-33"></a>For fun, let's inspect the Lisp value of the C string that was created
to hold <code>"http://www.cliki.net/CFFI"</code>.  By virtue of the implementation of
<code>add-curl-handle-cstring</code>, it should be accessible through the
hash table defined:

<pre class="example">  <span class="sc">cffi-user&gt;</span> (foreign-string-to-lisp
              (car (gethash *easy-handle* *easy-handle-cstrings*)))
  =&gt; "http://www.cliki.net/CFFI"
</pre>
   <p class="noindent">Looks like that worked, and <code>libcurl</code> now knows what
<acronym>URL</acronym> we want to retrieve.

   <p>Finally, we turn back to the <code>:errorbuffer</code> option mentioned at
the beginning of this section.  Whereas the abstraction added to
support string inputs works fine for cases like <code>CURLOPT_URL</code>, it
hides the detail of keeping the C string; for <code>:errorbuffer</code>,
however, we need that C string.

   <p>In a moment, we'll define something slightly cleaner, but for now,
remember that you can always hack around anything.  We're modifying
handle creation, so make sure you free the old handle before
redefining <code>free-easy-handle</code>.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defvar</span></i> <span class="special">*easy-handle-errorbuffers*</span> <span class="paren2">(<span class="lisp-bg">make-hash-table</span>)</span>
    <span class="string">"Hashtable of easy handles to C strings serving as error
  writeback buffers."</span></span>)</span>
   
  <span class="comment">;;; An extra byte is very little to pay for peace of mind.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*curl-error-size*</span> 257
    <span class="string">"Minimum char[] size used by cURL to report errors."</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> make-easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="string">"Answer a new CURL easy interface handle, to which the lifetime
  of C strings may be tied.  See `add-curl-handle-cstring'."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">easy-handle <span class="paren5">(<span class="lisp-bg">curl-easy-init</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-cstrings*</span></span>)</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">gethash easy-handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span>
              <span class="paren4">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> <span class="special">*curl-error-size*</span>
                             <span class="keyword">:initial-element</span> 0</span>)</span></span>)</span>
      easy-handle</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg">curl-easy-cleanup handle</span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-free <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mapc #'foreign-string-free
          <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">remhash handle <span class="special">*easy-handle-cstrings*</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> get-easy-handle-error <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Answer a string containing HANDLE's current error message."</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp
     <span class="paren3">(<span class="lisp-bg">gethash handle <span class="special">*easy-handle-errorbuffers*</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p>Be sure to once again set the options we've set thus far.  You may
wish to define yet another wrapper function to do this.

<div class="node">
<a name="Tutorial-Callbacks"></a>
<a name="Tutorial_002dCallbacks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dCompletion">Tutorial-Completion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dMemory">Tutorial-Memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.9 Calling Lisp from C</h3>

<p>If you have been reading
<a href="http://curl.haxx.se/libcurl/c/curl_easy_setopt.html"><code>curl_easy_setopt(3)</code></a>, you should have noticed that some options
accept a function pointer.  In particular, we need one function
pointer to set as <code>CURLOPT_WRITEFUNCTION</code>, to be called by
<code>libcurl</code> rather than the reverse, in order to receive data as it
is downloaded.

   <p>A binding writer without the aid of <acronym>FFI</acronym> usually approaches
this problem by writing a C function that accepts C data, converts to
the language's internal objects, and calls the callback provided by
the user, again in a reverse of usual practices.

   <p>The <acronym>CFFI</acronym> approach to callbacks precisely mirrors its differences
with the non-<acronym>FFI</acronym> approach on the &ldquo;calling C from Lisp&rdquo;
side, which we have dealt with exclusively up to now.  That is, you
define a callback function in Lisp using <code>defcallback</code>, and
<acronym>CFFI</acronym> effectively creates a C function to be passed as a function
pointer.

   <blockquote>
<strong>Implementor's note:</strong> <em>This is much trickier than calling C functions from Lisp, as
it literally involves somehow generating a new C function that is as
good as any created by the compiler.  Therefore, not all Lisps support
them.  See <a href="#Implementation-Support">Implementation Support</a>, for information about <acronym>CFFI</acronym>
support issues in this and other areas.  You may want to consider
changing to a Lisp that supports callbacks in order to continue with
this tutorial.</em>
</blockquote>

   <p><a name="index-callback-definition-34"></a><a name="index-defining-callbacks-35"></a>Defining a callback is very similar to defining a callout; the main
difference is that we must provide some Lisp forms to be evaluated as
part of the callback.  Here is the signature for the function the
<code>:writefunction</code> option takes:

<pre class="example">  size_t
  <var>function</var>(void *ptr, size_t size, size_t nmemb, void *stream);
</pre>
   <blockquote>
<strong>Implementor's note:</strong> <em>size_t is almost always an unsigned int.  You can get this
and many other types using feature tests for your system by using
cffi-grovel.</em>
</blockquote>

   <p>The above signature trivially translates into a <acronym>CFFI</acronym>
<code>defcallback</code> form, as follows.

<pre class="lisp">  <span class="comment">;;; Alias in case size_t changes.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> size <span class="keyword">:unsigned-int</span></span>)</span>
   
  <span class="comment">;;; To be set as the CURLOPT_WRITEFUNCTION of every easy handle.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> easy-write size <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">ptr <span class="keyword">:pointer</span></span>)</span> <span class="paren3">(<span class="lisp-bg">size size</span>)</span>
                                <span class="paren3">(<span class="lisp-bg">nmemb size</span>)</span> <span class="paren3">(<span class="lisp-bg">stream <span class="keyword">:pointer</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">data-size <span class="paren5">(<span class="lisp-bg">* size nmemb</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">handler-case
        <span class="comment">;; We use the dynamically-bound *easy-write-procedure* to
  </span>      <span class="comment">;; call a closure with useful lexical context.
  </span>      <span class="paren4">(<span class="lisp-bg"><i><span class="symbol">progn</span></i> <span class="paren5">(<span class="lisp-bg">funcall <span class="paren6">(<span class="lisp-bg">symbol-value '<span class="special">*easy-write-procedure*</span></span>)</span>
                        <span class="paren6">(<span class="lisp-bg">foreign-string-to-lisp ptr data-size nil</span>)</span></span>)</span>
               data-size</span>)</span>         <span class="comment">;indicates success
  </span>      <span class="comment">;; The WRITEFUNCTION should return something other than the
  </span>      <span class="comment">;; #bytes available to signal an error.
  </span>      <span class="paren4">(<span class="lisp-bg">error <span class="paren5">(<span class="lisp-bg"></span>)</span> <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren6">(<span class="lisp-bg">zerop data-size</span>)</span> 1 0</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p>First, note the correlation of the first few forms, used to declare
the C function's signature, with the signature in C syntax.  We
provide a Lisp name for the function, its return type, and a name and
type for each argument.

   <p>In the body, we call the dynamically-bound
<code>*easy-write-procedure*</code> with a &ldquo;finished&rdquo; translation, of
pulling together the raw data and size into a Lisp string, rather than
deal with the data directly.  As part of calling
<code>curl_easy_perform</code> later, we'll bind that variable to a closure
with more useful lexical bindings than the top-level
<code>defcallback</code> form.

   <p>Finally, we make a halfhearted effort to prevent non-local exits from
unwinding the C stack, covering the most likely case with an
<code>error</code> handler, which is usually triggered
unexpectedly.<a rel="footnote" href="#fn-9" name="fnd-9"><sup>9</sup></a>  The reason is that most C code is written to
understand its own idiosyncratic error condition, implemented above in
the case of <code>curl_easy_perform</code>, and more &ldquo;undefined behavior&rdquo;
can result if we just wipe C stack frames without allowing them to
execute whatever cleanup actions as they like.

   <p>Using the <code>CURLoption</code> enumeration in <samp><span class="file">curl.h</span></samp> once more, we
can describe the new option by modifying and reevaluating
<code>define-curl-options</code>.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-curl-options</span></i> curl-option
      <span class="paren2">(<span class="lisp-bg">long 0 objectpoint 10000 functionpoint 20000 off-t 30000</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:noprogress</span> long 43</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nosignal</span> long 99</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:errorbuffer</span> objectpoint 10</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:url</span> objectpoint 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:writefunction</span> functionpoint 11</span>)</span></span>)</span> ;new item here
</pre>
   <p>Finally, we can use the defined callback and the new
<code>set-curl-option-writefunction</code> to finish configuring the easy
handle, using the <code>callback</code> macro to retrieve a <acronym>CFFI</acronym>
<code>:pointer</code>, which works like a function pointer in C code.

<pre class="example">  <span class="sc">cffi-user&gt;</span> (set-curl-option-writefunction
              *easy-handle* (callback easy-write))
  =&gt; 0
</pre>
   <div class="node">
<a name="Tutorial-Completion"></a>
<a name="Tutorial_002dCompletion"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dTypes">Tutorial-Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.10 A complete <acronym>FFI</acronym>?</h3>

<!-- TeX goes insane on @uref{@clikicffi{}} -->
<p>With all options finally set and a medium-level interface developed,
we can finish the definition and retrieve
<a href="http://www.cliki.net/CFFI">http://www.cliki.net/CFFI</a>, as is done in the tutorial.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"curl_easy_perform"</span> curl-code
    <span class="paren2">(<span class="lisp-bg">handle easy-handle</span>)</span></span>)</span>
</pre>
   <pre class="example">  <span class="sc">cffi-user&gt;</span> (with-output-to-string (contents)
               (let ((*easy-write-procedure*
                       (lambda (string)
                         (write-string string contents))))
                 (declare (special *easy-write-procedure*))
                 (curl-easy-perform *easy-handle*)))
  =&gt; "&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\"
  ...
  Now fear, comprehensively&lt;/P&gt;
  "
</pre>
   <p>Of course, that itself is slightly unwieldy, so you may want to define
a function around it that simply retrieves a <acronym>URL</acronym>.  I will
leave synthesis of all the relevant <acronym>REPL</acronym> forms presented
thus far into a single function as an exercise for the reader.

   <p>The remaining sections of this tutorial explore some advanced features
of <acronym>CFFI</acronym>; the definition of new types will receive special
attention.  Some of these features are essential for particular
foreign function calls; some are very helpful when trying to develop a
Lispy interface to C.

<div class="node">
<a name="Tutorial-Types"></a>
<a name="Tutorial_002dTypes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial_002dConclusion">Tutorial-Conclusion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dCompletion">Tutorial-Completion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.11 Defining new types</h3>

<p>We've occasionally used the <code>defctype</code> macro in previous sections
as a kind of documentation, much what you'd use <code>typedef</code> for in
C.  We also tried one special kind of type definition, the
<code>defcenum</code> type.  See <a href="#defcstruct">defcstruct</a>, for a definition macro that
may come in handy if you need to use C <code>struct</code>s as data.

   <p><a name="index-type-definition-36"></a><a name="index-data-in-Lisp-and-C-37"></a><a name="index-translating-types-38"></a>However, all of these are mostly sugar for the powerful underlying
foreign type interface called <dfn>type translators</dfn>.  You can easily
define new translators for any simple named foreign type.  Since we've
defined the new type <code>curl-code</code> to use as the return type for
various <code>libcurl</code> functions, we can use that to directly convert
c<acronym>URL</acronym> errors to Lisp errors.

   <p><code>defctype</code>'s purpose is to define simple <code>typedef</code>-like
aliases.  In order to use <dfn>type translators</dfn> we must use the
<code>define-foreign-type</code> macro.  So let's redefine <code>curl-code</code>
using it.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> curl-code-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> curl-code</span>)</span></span>)</span>
</pre>
   <p><code>define-foreign-type</code> is a thin wrapper around <code>defclass</code>. 
For now, all you need to know in the context of this example is that
it does what <code>(defctype curl-code :int)</code> would do and,
additionally, defines a new class <code>curl-code-type</code> which we will
take advantage of shortly.

   <p>The <code>CURLcode</code> enumeration seems to follow the typical error code
convention of &lsquo;<samp><span class="samp">0</span></samp>&rsquo; meaning all is well, and each non-zero integer
indicating a different kind of error.  We can apply that trivially to
differentiate between normal exits and error exits.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-condition</span></i> curl-code-error <span class="paren2">(<span class="lisp-bg">error</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">$code <span class="keyword">:initarg</span> <span class="keyword">:curl-code</span> <span class="keyword">:reader</span> curl-error-code</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:report</span> <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">lambda</span></i> <span class="paren4">(<span class="lisp-bg">c stream</span>)</span>
               <span class="paren4">(<span class="lisp-bg">format stream <span class="string">"libcurl function returned error ~A"</span>
                              <span class="paren5">(<span class="lisp-bg">curl-error-code c</span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:documentation</span> <span class="string">"Signalled when a libcurl function answers
  a code other than CURLE_OK."</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-from-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type curl-code-type</span>)</span></span>)</span>
    <span class="string">"Raise a CURL-CODE-ERROR if VALUE, a curl-code, is non-zero."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> <span class="paren3">(<span class="lisp-bg">zerop value</span>)</span>
        <span class="keyword">:curle-ok</span>
        <span class="paren3">(<span class="lisp-bg">error 'curl-code-error <span class="keyword">:curl-code</span> value</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">The heart of this translator is new method
<code>translate-from-foreign</code>.  By specializing the <var>type</var>
parameter on <code>curl-code-type</code>, we immediately modify the behavior
of every function that returns a <code>curl-code</code> to pass the result
through this new method.

   <p>To see the translator in action, try invoking a function that returns
a <code>curl-code</code>.  You need to reevaluate the respective
<code>defcfun</code> form so that it picks up the new <code>curl-code</code>
definition.

<pre class="example">  <span class="sc">cffi-user&gt;</span> (set-curl-option-nosignal *easy-handle* 1)
  =&gt; :CURLE-OK
</pre>
   <p class="noindent">As the result was &lsquo;<samp><span class="samp">0</span></samp>&rsquo;, the new method returned <code>:curle-ok</code>,
just as specified.<a rel="footnote" href="#fn-10" name="fnd-10"><sup>10</sup></a>  I will leave disjoining the separate
<code>CURLcode</code>s into condition types and improving the <code>:report</code>
function as an exercise for you.

   <p>The creation of <code>*easy-handle-cstrings*</code> and
<code>*easy-handle-errorbuffers*</code> as properties of <code>easy-handle</code>s
is a kluge.  What we really want is a Lisp structure that stores these
properties along with the C pointer.  Unfortunately,
<code>easy-handle</code> is currently just a fancy name for the foreign type
<code>:pointer</code>; the actual pointer object varies from Common Lisp
implementation to implementation, needing only to satisfy
<code>pointerp</code> and be returned from <code>make-pointer</code> and friends.

   <p>One solution that would allow us to define a new Lisp structure to
represent <code>easy-handle</code>s would be to write a wrapper around every
function that currently takes an <code>easy-handle</code>; the wrapper would
extract the pointer and pass it to the foreign function.  However, we
can use type translators to more elegantly integrate this
&ldquo;translation&rdquo; into the foreign function calling framework, using
<code>translate-to-foreign</code>.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defclass</span></i> easy-handle <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">pointer <span class="keyword">:initform</span> <span class="paren4">(<span class="lisp-bg">curl-easy-init</span>)</span>
              <span class="keyword">:documentation</span> <span class="string">"Foreign pointer from curl_easy_init"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg">error-buffer
      <span class="keyword">:initform</span> <span class="paren4">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> <span class="special">*curl-error-size*</span>
                               <span class="keyword">:initial-element</span> 0</span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"C string describing last error"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg">c-strings <span class="keyword">:initform</span> '<span class="paren4">(<span class="lisp-bg"></span>)</span>
                <span class="keyword">:documentation</span> <span class="string">"C strings set as options"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:documentation</span> <span class="string">"I am a parameterization you may pass to
  curl-easy-perform to perform a cURL network protocol request."</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> initialize-instance <span class="keyword">:after</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">self easy-handle</span>)</span> &amp;key</span>)</span>
    <span class="paren2">(<span class="lisp-bg">set-curl-option-errorbuffer self <span class="paren3">(<span class="lisp-bg">slot-value self 'error-buffer</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> add-curl-handle-cstring <span class="paren2">(<span class="lisp-bg">handle cstring</span>)</span>
    <span class="string">"Add CSTRING to be freed when HANDLE is, answering CSTRING."</span>
    <span class="paren2">(<span class="lisp-bg">car <span class="paren3">(<span class="lisp-bg">push cstring <span class="paren4">(<span class="lisp-bg">slot-value handle 'c-strings</span>)</span></span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> get-easy-handle-error <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Answer a string containing HANDLE's current error message."</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp
     <span class="paren3">(<span class="lisp-bg">slot-value handle 'error-buffer</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> free-easy-handle <span class="paren2">(<span class="lisp-bg">handle</span>)</span>
    <span class="string">"Free CURL easy interface HANDLE and any C strings created to
  be its options."</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-slots</span></i> <span class="paren3">(<span class="lisp-bg">pointer error-buffer c-strings</span>)</span> handle
      <span class="paren3">(<span class="lisp-bg">curl-easy-cleanup pointer</span>)</span>
      <span class="paren3">(<span class="lisp-bg">foreign-free error-buffer</span>)</span>
      <span class="paren3">(<span class="lisp-bg">mapc #'foreign-string-free c-strings</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> easy-handle-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> easy-handle</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-to-foreign <span class="paren2">(<span class="lisp-bg">handle <span class="paren3">(<span class="lisp-bg">type easy-handle-type</span>)</span></span>)</span>
    <span class="string">"Extract the pointer from an easy-HANDLE."</span>
    <span class="paren2">(<span class="lisp-bg">slot-value handle 'pointer</span>)</span></span>)</span>
</pre>
   <p>While we changed some of the Lisp functions defined earlier to use
<acronym>CLOS</acronym> slots rather than hash tables, the foreign functions
work just as well as they did before.

   <p><a name="index-limitations-of-type-translators-39"></a>The greatest strength, and the greatest limitation, of the type
translator comes from its generalized interface.  As stated
previously, we could define all foreign function calls in terms of the
primitive foreign types provided by <acronym>CFFI</acronym>.  The type translator
interface allows us to cleanly specify the relationship between Lisp
and C data, independent of where it appears in a function call.  This
independence comes at a price; for example, it cannot be used to
modify translation semantics based on other arguments to a function
call.  In these cases, you should rely on other features of Lisp,
rather than the powerful, yet domain-specific, type translator
interface.

<div class="node">
<a name="Tutorial-Conclusion"></a>
<a name="Tutorial_002dConclusion"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial_002dTypes">Tutorial-Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Tutorial">Tutorial</a>

</div>

<h3 class="section">4.12 What's next?</h3>

<p><acronym>CFFI</acronym> provides a rich and powerful foundation for communicating with
foreign libraries; as we have seen, it is up to you to make that
experience a pleasantly Lispy one.  This tutorial does not cover all
the features of <acronym>CFFI</acronym>; please see the rest of the manual for
details.  In particular, if something seems obviously missing, it is
likely that either code or a good reason for lack of code is already
present.

   <blockquote>
<strong>Implementor's note:</strong> <em>There are some other things in <acronym>CFFI</acronym> that might deserve
tutorial sections, such as free-translated-object, or structs.  Let us
know which ones you care about.</em>
</blockquote>

<!-- =================================================================== -->
<!-- CHAPTER: Wrapper generators -->
<div class="node">
<a name="Wrapper-generators"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Foreign-Types">Foreign Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial">Tutorial</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Wrapper generators</h2>

<p><acronym>CFFI</acronym>'s interface is designed for human programmers, being aimed at
aesthetic as well as technical sophistication.  However, there are a
few programs aimed at translating C and C++ header files, or
approximations thereof, into <acronym>CFFI</acronym> forms constituting a foreign
interface to the symbols in those files.

   <p>These wrapper generators are known to support output of <acronym>CFFI</acronym> forms.

     <dl>
<dt><a href="http://www.cliki.net/Verrazano">Verrazano</a><dd>Designed specifically for Common Lisp.  Uses <acronym>GCC</acronym>'s parser
output in <acronym>XML</acronym> format to discover functions, variables, and
other header file data.  This means you need <acronym>GCC</acronym> to generate
forms; on the other hand, the parser employed is mostly compliant with
<acronym>ANSI</acronym> C.

     <br><dt><a href="http://www.cliki.net/SWIG">SWIG</a><dd>A foreign interface generator originally designed to generate Python
bindings, it has been ported to many other systems, including <acronym>CFFI</acronym>
in version 1.3.28.  Includes its own C declaration munger, not
intended to be fully-compliant with <acronym>ANSI</acronym> C. 
</dl>

   <p>First, this manual does not describe use of these other programs; they
have documentation of their own.  If you have problems using a
generated interface, please look at the output <acronym>CFFI</acronym> forms and
verify that they are a correct <acronym>CFFI</acronym> interface to the library in
question; if they are correct, contact <acronym>CFFI</acronym> developers with
details, keeping in mind that they communicate in terms of those forms
rather than any particular wrapper generator.  Otherwise, contact the
maintainers of the wrapper generator you are using, provided you can
reasonably expect more accuracy from the generator.

   <p>When is more accuracy an unreasonable expectation?  As described in
the tutorial (see <a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>), the information in C declarations is insufficient to
completely describe every interface.  In fact, it is quite common to
run into an interface that cannot be handled automatically, and
generators should be excused from generating a complete interface in
these cases.

   <p>As further described in the tutorial, the thinnest Lisp interface to a
C function is not always the most pleasant one.  In many cases, you
will want to manually write a Lispier interface to the C functions
that interest you.

   <p>Wrapper generators should be treated as time-savers, not complete
automation of the full foreign interface writing job.  Reports of the
amount of work done by generators vary from 30% to 90%.  The
incremental development style enabled by <acronym>CFFI</acronym> generally reduces
this proportion below that for languages like Python.

<!-- Where I got the above 30-90% figures: -->
<!-- 30%: lemonodor's post about SWIG -->
<!-- 90%: Balooga on #lisp.  He said 99%, but that's probably an -->
<!-- exaggeration (leave it to me to pass judgement :) -->
<!-- stephen -->
<!-- =================================================================== -->
<!-- CHAPTER: Foreign Types -->
<div class="node">
<a name="Foreign-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Pointers">Pointers</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Wrapper-generators">Wrapper generators</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Foreign Types</h2>

<p>Foreign types describe how data is translated back and forth between C
and Lisp. <acronym>CFFI</acronym> provides various built-in types and allows the user to
define new types.

<ul class="menu">
<li><a accesskey="1" href="#Built_002dIn-Types">Built-In Types</a>
<li><a accesskey="2" href="#Other-Types">Other Types</a>
<li><a accesskey="3" href="#Defining-Foreign-Types">Defining Foreign Types</a>
<li><a accesskey="4" href="#Foreign-Type-Translators">Foreign Type Translators</a>
<li><a accesskey="5" href="#Optimizing-Type-Translators">Optimizing Type Translators</a>
<li><a accesskey="6" href="#Foreign-Structure-Types">Foreign Structure Types</a>
<li><a accesskey="7" href="#Allocating-Foreign-Objects">Allocating Foreign Objects</a>

</li></ul>
<p>Dictionary

</p>
<ul class="menu">
<li><a accesskey="8" href="#convert_002dfrom_002dforeign">convert-from-foreign</a>
<li><a accesskey="9" href="#convert_002dto_002dforeign">convert-to-foreign</a>
<li><a href="#defbitfield">defbitfield</a>
<li><a href="#defcstruct">defcstruct</a>
<li><a href="#defcunion">defcunion</a>
<li><a href="#defctype">defctype</a>
<li><a href="#defcenum">defcenum</a>
<!-- * define-type-spec-parser:: -->
<li><a href="#define_002dforeign_002dtype">define-foreign-type</a>
<li><a href="#define_002dparse_002dmethod">define-parse-method</a>
<!-- * explain-foreign-slot-value: -->
<li><a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>
<li><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>
<li><a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>
<li><a href="#foreign_002denum_002dvalue">foreign-enum-value</a>
<li><a href="#foreign_002dslot_002dnames">foreign-slot-names</a>
<li><a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>
<li><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>
<li><a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>
<li><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>
<li><a href="#foreign_002dtype_002dsize">foreign-type-size</a>
<li><a href="#free_002dconverted_002dobject">free-converted-object</a>
<li><a href="#free_002dtranslated_002dobject">free-translated-object</a>
<li><a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>
<li><a href="#translate_002dto_002dforeign">translate-to-foreign</a>
<li><a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a>
<li><a href="#with_002dforeign_002dslots">with-foreign-slots</a>
</ul>

<div class="node">
<a name="Built-In-Types"></a>
<a name="Built_002dIn-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Other-Types">Other Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Foreign-Types">Foreign Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.1 Built-In Types</h3>

<div class="defun">
&mdash; Foreign Type: <b>:char</b><var><a name="index-g_t_003achar-40"></a></var><br>
     </div>

<div class="defun">
&mdash; Foreign Type: <b>:unsigned-char</b><var><a name="index-g_t_003aunsigned_002dchar-41"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:short</b><var><a name="index-g_t_003ashort-42"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:unsigned-short</b><var><a name="index-g_t_003aunsigned_002dshort-43"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:int</b><var><a name="index-g_t_003aint-44"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:unsigned-int</b><var><a name="index-g_t_003aunsigned_002dint-45"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:long</b><var><a name="index-g_t_003along-46"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:unsigned-long</b><var><a name="index-g_t_003aunsigned_002dlong-47"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:long-long</b><var><a name="index-g_t_003along_002dlong-48"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:unsigned-long-long</b><var><a name="index-g_t_003aunsigned_002dlong_002dlong-49"></a></var><br>
        </div>

   <p>These types correspond to the native C integer types according to the
<acronym>ABI</acronym> of the Lisp implementation's host system.

   <p><code>:long-long</code> and <code>:unsigned-long-long</code> are not supported
natively on all implementations. However, they are emulated by
<code>mem-ref</code> and <code>mem-set</code>.

   <p>When those types are <strong>not</strong> available, the symbol
<code>cffi-sys::no-long-long</code> is pushed into <code>*features*</code>.

<div class="defun">
&mdash; Foreign Type: <b>:uchar</b><var><a name="index-g_t_003auchar-50"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:ushort</b><var><a name="index-g_t_003aushort-51"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:uint</b><var><a name="index-g_t_003auint-52"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:ulong</b><var><a name="index-g_t_003aulong-53"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:llong</b><var><a name="index-g_t_003allong-54"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:ullong</b><var><a name="index-g_t_003aullong-55"></a></var><br>
        </div>

   <p>For convenience, the above types are provided as shortcuts for
<code>unsigned-char</code>, <code>unsigned-short</code>, <code>unsigned-int</code>,
<code>unsigned-long</code>, <code>long-long</code> and <code>unsigned-long-long</code>,
respectively.

<div class="defun">
&mdash; Foreign Type: <b>:int8</b><var><a name="index-g_t_003aint8-56"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:uint8</b><var><a name="index-g_t_003auint8-57"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:int16</b><var><a name="index-g_t_003aint16-58"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:uint16</b><var><a name="index-g_t_003auint16-59"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:int32</b><var><a name="index-g_t_003aint32-60"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:uint32</b><var><a name="index-g_t_003auint32-61"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:int64</b><var><a name="index-g_t_003aint64-62"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:uint64</b><var><a name="index-g_t_003auint64-63"></a></var><br>
        </div>

   <p>Foreign integer types of specific sizes, corresponding to the C types
defined in <code>stdint.h</code>.

<!-- @ForeignType{:size} -->
<!-- @ForeignType{:ssize} -->
<!-- @ForeignType{:ptrdiff} -->
<!-- @ForeignType{:time} -->
<!-- Foreign integer types corresponding to the standard C types (without -->
<!-- the @code{_t} suffix). -->
<!-- @impnote{These are not implemented yet. -luis} -->
<!-- @impnote{I'm sure there are more of these that could be useful, let's -->
<!-- add any types that can't be defined portably to this list as -->
<!-- necessary. -james} -->
<div class="defun">
&mdash; Foreign Type: <b>:float</b><var><a name="index-g_t_003afloat-64"></a></var><br>
        </div>

<div class="defun">
&mdash; Foreign Type: <b>:double</b><var><a name="index-g_t_003adouble-65"></a></var><br>
        </div>

   <p>On all systems, the <code>:float</code> and <code>:double</code> types represent a
C <code>float</code> and <code>double</code>, respectively. On most but not all
systems, <code>:float</code> and <code>:double</code> represent a Lisp
<code>single-float</code> and <code>double-float</code>, respectively. It is not
so useful to consider the relationship between Lisp types and C types
as isomorphic, as simply to recognize the relationship, and relative
precision, among each respective category.

<div class="defun">
&mdash; Foreign Type: <b>:long-double</b><var><a name="index-g_t_003along_002ddouble-66"></a></var><br>
        </div>

   <p>This type is only supported on SCL.

<div class="defun">
&mdash; Foreign Type: <b>:pointer</b><var> &amp;optional type<a name="index-g_t_003apointer-67"></a></var><br>
        </div>

   <p>A foreign pointer to an object of any type, corresponding to
<code>void *</code>.  You can optionally specify type of pointer
(e.g. <code>(:pointer :char)</code>).  Although <acronym>CFFI</acronym> won't do anything
with that information yet, it is useful for documentation purposes.

<div class="defun">
&mdash; Foreign Type: <b>:void</b><var><a name="index-g_t_003avoid-68"></a></var><br>
        </div>

   <p>No type at all. Only valid as the return type of a function.

<div class="node">
<a name="Other-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Defining-Foreign-Types">Defining Foreign Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Built_002dIn-Types">Built-In Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.2 Other Types</h3>

<p><acronym>CFFI</acronym> also provides a few useful types that aren't built-in C
types.

<div class="defun">
&mdash; Foreign Type: <b>:string</b><var><a name="index-g_t_003astring-69"></a></var><br>
        </div>

   <p>The <code>:string</code> type performs automatic conversion between Lisp and
C strings. Note that, in the case of functions the converted C string
will have dynamic extent (i.e. it will be automatically freed after
the foreign function returns).

   <p>In addition to Lisp strings, this type will accept foreign pointers
and pass them unmodified.

   <p>A method for <a href="#free_002dtranslated_002dobject">free-translated-object</a> is specialized for this
type. So, for example, foreign strings allocated by this type and
passed to a foreign function will be freed after the function
returns.

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"SHELL"</span> <span class="keyword">:string</span></span>)</span>
  =&gt; "/bin/bash"
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"abcdef"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:string</span> str <span class="keyword">:int</span></span>)</span></span>)</span>
  =&gt; 6
</pre>
   <div class="defun">
&mdash; Foreign Type: <b>:string+ptr</b><var><a name="index-g_t_003astring_002bptr-70"></a></var><br>
        </div>

   <p>Like <code>:string</code> but returns a list with two values when convert
from C to Lisp: a Lisp string and the C string's foreign pointer.

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"SHELL"</span> <span class="keyword">:string+ptr</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="string">"/bin/bash"</span> #.<span class="paren2">(<span class="lisp-bg">SB-SYS:INT-SAP #XBFFFFC6F</span>)</span></span>)</span>
</pre>
   <div class="defun">
&mdash; Foreign Type: <b>:boolean</b><var> &amp;optional </var>(<var>base-type :int</var>)<var><a name="index-g_t_003aboolean-71"></a></var><br>
        </div>

   <p>The <code>:boolean</code> type converts between a Lisp boolean and a C
boolean. It canonicalizes to <var>base-type</var> which is <code>:int</code> by
default.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">convert-to-foreign nil <span class="keyword">:boolean</span></span>)</span> =&gt; 0
  <span class="paren1">(<span class="lisp-bg">convert-to-foreign t <span class="keyword">:boolean</span></span>)</span> =&gt; 1
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 0 <span class="keyword">:boolean</span></span>)</span> =&gt; nil
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 1 <span class="keyword">:boolean</span></span>)</span> =&gt; t
</pre>
   <div class="defun">
&mdash; Foreign Type: <b>:wrapper</b><var> base-type &amp;key to-c from-c<a name="index-g_t_003awrapper-72"></a></var><br>
        </div>

   <p>The <code>:wrapper</code> type stores two symbols passed to the <var>to-c</var>
and <var>from-c</var> arguments. When a value is being translated to or
from C, this type <code>funcall</code>s the respective symbol.

   <p><code>:wrapper</code> types will be typedefs for <var>base-type</var> and will
inherit its translators, if any.

   <p>Here's an example of how the <code>:boolean</code> type could be defined in
terms of <code>:wrapper</code>.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bool-c-to-lisp <span class="paren2">(<span class="lisp-bg">value</span>)</span>
    <span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">zerop value</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bool-lisp-to-c <span class="paren2">(<span class="lisp-bg">value</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> value 1 0</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-bool <span class="paren2">(<span class="lisp-bg"><span class="keyword">:wrapper</span> <span class="keyword">:int</span> <span class="keyword">:from-c</span> bool-c-to-lisp
                                   <span class="keyword">:to-c</span> bool-lisp-to-c</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg">convert-to-foreign nil 'my-bool</span>)</span> =&gt; 0
  <span class="paren1">(<span class="lisp-bg">convert-from-foreign 1 'my-bool</span>)</span> =&gt; t
</pre>
   <div class="node">
<a name="Defining-Foreign-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Foreign-Type-Translators">Foreign Type Translators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Other-Types">Other Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.3 Defining Foreign Types</h3>

<p>You can define simple C-like <code>typedef</code>s through the
<code>defctype</code> macro. Defining a typedef is as simple as giving
<code>defctype</code> a new name and the name of the type to be wrapped.

<pre class="lisp">  <span class="comment">;;; Define MY-INT as an alias for the built-in type :INT.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-int <span class="keyword">:int</span></span>)</span>
</pre>
   <p>With this type definition, one can, for instance, declare arguments to
foreign functions as having the type <code>my-int</code>, and they will be
passed as integers.

<h4 class="subheading">More complex types</h4>

<p><acronym>CFFI</acronym> offers another way to define types through
<code>define-foreign-type</code>, a thin wrapper macro around
<code>defclass</code>. As an example, let's go through the steps needed to
define a <code>(my-string &amp;key encoding)</code> type. First, we need to
define our type class:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> my-string-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">encoding <span class="keyword">:reader</span> string-type-encoding <span class="keyword">:initarg</span> <span class="keyword">:encoding</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:pointer</span></span>)</span></span>)</span>
</pre>
   <p>The <code>:actual-type</code> class option tells CFFI that this type will
ultimately be passed to and received from foreign code as a
<code>:pointer</code>. Now you need to tell CFFI how to parse a type
specification such as <code>(my-string :encoding :utf8)</code> into an
instance of <code>my-string-type</code>.  We do that with
<code>define-parse-method</code>:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-parse-method</span></i> my-string <span class="paren2">(<span class="lisp-bg">&amp;key <span class="paren3">(<span class="lisp-bg">encoding <span class="keyword">:utf-8</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">make-instance 'my-string-type <span class="keyword">:encoding</span> encoding</span>)</span></span>)</span>
</pre>
   <p>The next section describes how make this type actually translate
between C and Lisp strings.

<div class="node">
<a name="Foreign-Type-Translators"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Optimizing-Type-Translators">Optimizing Type Translators</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Defining-Foreign-Types">Defining Foreign Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.4 Foreign Type Translators</h3>

<p>Type translators are used to automatically convert Lisp values to or
from foreign values.  For example, using type translators, one can
take the <code>my-string</code> type defined in the previous section and
specify that it should:

     <ul>
<li>convert C strings to Lisp strings;
<li>convert Lisp strings to newly allocated C strings;
<li>free said C strings when they are no longer needed. 
</ul>

   <p>In order to tell <acronym>CFFI</acronym> how to automatically convert Lisp values to
foreign values, define a specialized method for the
<code>translate-to-foreign</code> generic function:

<pre class="lisp">  <span class="comment">;;; Define a method that converts Lisp strings to C strings.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-to-foreign <span class="paren2">(<span class="lisp-bg">string <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-alloc string <span class="keyword">:encoding</span> <span class="paren3">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">From now on, whenever an object is passed as a <code>my-string</code> to a
foreign function, this method will be invoked to convert the Lisp
value. To perform the inverse operation, which is needed for functions
that return a <code>my-string</code>, specialize the
<code>translate-from-foreign</code> generic function in the same manner:

<pre class="lisp">  <span class="comment">;;; Define a method that converts C strings to Lisp strings.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-from-foreign <span class="paren2">(<span class="lisp-bg">pointer <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp pointer <span class="keyword">:encoding</span> <span class="paren3">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">When a <code>translate-to-foreign</code> method requires allocation of
foreign memory, you must also define a <code>free-translated-object</code>
method to free the memory once the foreign object is no longer needed,
otherwise you'll be faced with memory leaks.  This generic function is
called automatically by <acronym>CFFI</acronym> when passing objects to foreign
functions. Let's do that:

<pre class="lisp">  <span class="comment">;;; Free strings allocated by translate-to-foreign.
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> free-translated-object <span class="paren2">(<span class="lisp-bg">pointer <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span> param</span>)</span>
    <span class="paren2">(<span class="lisp-bg">declare <span class="paren3">(<span class="lisp-bg">ignore param</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">foreign-string-free pointer</span>)</span></span>)</span>
</pre>
   <p class="noindent">In this specific example, we don't need the <var>param</var> argument, so
we ignore it. See <a href="#free_002dtranslated_002dobject">free-translated-object</a>, for an explanation of
its purpose and how you can use it.

   <p>A type translator does not necessarily need to convert the value.  For
example, one could define a typedef for <code>:pointer</code> that ensures,
in the <code>translate-to-foreign</code> method, that the value is not a
null pointer, signalling an error if a null pointer is passed.  This
would prevent some pointer errors when calling foreign functions that
cannot handle null pointers.

   <p><strong>Please note:</strong> these methods are meant as extensible hooks
only, and you should not call them directly.  Use
<code>convert-to-foreign</code>, <code>convert-from-foreign</code> and
<code>free-converted-object</code> instead.

   <p>See <a href="#Tutorial_002dTypes">Defining new types</a>, for another example of
type translators.

<div class="node">
<a name="Optimizing-Type-Translators"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Foreign-Structure-Types">Foreign Structure Types</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Foreign-Type-Translators">Foreign Type Translators</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.5 Optimizing Type Translators</h3>

<p><a name="index-type-translators_002c-optimizing-73"></a><a name="index-compiler-macros-for-type-translation-74"></a><a name="index-defining-type_002dtranslation-compiler-macros-75"></a>Being based on generic functions, the type translation mechanism
described above can add a bit of overhead.  This is usually not
significant, but we nevertheless provide a way of getting rid of the
overhead for the cases where it matters.

   <p>A good way to understand this issue is to look at the code generated
by <code>defcfun</code>. Consider the following example using the previously
defined <code>my-string</code> type:

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> foo my-string <span class="paren3">(<span class="lisp-bg">x my-string</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg">multiple-value-bind <span class="paren3">(<span class="lisp-bg"><span class="keyword">#:G2019</span> <span class="keyword">#:PARAM3149</span></span>)</span>
        <span class="paren3">(<span class="lisp-bg">translate-to-foreign x #&lt;MY-STRING-TYPE {11ED5A79}&gt;</span>)</span>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">unwind-protect</span></i>
          <span class="paren4">(<span class="lisp-bg">translate-from-foreign
           <span class="paren5">(<span class="lisp-bg">foreign-funcall <span class="string">"foo"</span> <span class="keyword">:pointer</span> <span class="keyword">#:G2019</span> <span class="keyword">:pointer</span></span>)</span>
           #&lt;MY-STRING-TYPE {11ED5659}&gt;</span>)</span>
        <span class="paren4">(<span class="lisp-bg">free-translated-object <span class="keyword">#:G2019</span> #&lt;MY-STRING-TYPE {11ED51A79}&gt;
                                <span class="keyword">#:PARAM3149</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">In order to get rid of those generic function calls, <acronym>CFFI</acronym> has
another set of extensible generic functions that provide functionality
similar to <acronym>CL</acronym>'s compiler macros:
<code>expand-to-foreign-dyn</code>, <code>expand-to-foreign</code> and
<code>expand-from-foreign</code>. Here's how one could define a
<code>my-boolean</code> with them:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> my-boolean-type <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:actual-type</span> <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:simple-parser</span> my-boolean</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-to-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type my-boolean-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">if</span></i> ,value 1 0</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-from-foreign <span class="paren2">(<span class="lisp-bg">value <span class="paren3">(<span class="lisp-bg">type my-boolean-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">zerop ,value</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">And here's what the macroexpansion of a function using this type would
look like:

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> bar my-boolean <span class="paren3">(<span class="lisp-bg">x my-boolean</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> bar <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">#:g3182</span> <span class="paren5">(<span class="lisp-bg"><i><span class="symbol">if</span></i> x 1 0</span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">not <span class="paren4">(<span class="lisp-bg">zerop <span class="paren5">(<span class="lisp-bg">foreign-funcall <span class="string">"bar"</span> <span class="keyword">:int</span> <span class="keyword">#:g3182</span> <span class="keyword">:int</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">No generic function overhead.

   <p>Let's go back to our <code>my-string</code> type.  The expansion interface
has no equivalent of <code>free-translated-object</code>; you must instead
define a method on <code>expand-to-foreign-dyn</code>, the third generic
function in this interface.  This is especially useful when you can
allocate something much more efficiently if you know the object has
dynamic extent, as is the case with function calls that don't save the
relevant allocated arguments.

   <p>This exactly what we need for the <code>my-string</code> type:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-from-foreign <span class="paren2">(<span class="lisp-bg">form <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    `<span class="paren2">(<span class="lisp-bg">foreign-string-to-lisp ,form</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> expand-to-foreign-dyn <span class="paren2">(<span class="lisp-bg">value var body <span class="paren3">(<span class="lisp-bg">type my-string-type</span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">encoding <span class="paren5">(<span class="lisp-bg">string-type-encoding type</span>)</span></span>)</span></span>)</span>
      `<span class="paren3">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren4">(<span class="lisp-bg">,var ,value <span class="keyword">:encoding</span> ',encoding</span>)</span>
         ,@body</span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">So let's look at the macro expansion:

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">macroexpand-1 '<span class="paren2">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> foo my-string <span class="paren3">(<span class="lisp-bg">x my-string</span>)</span></span>)</span></span>)</span>
  <span class="comment">;; (simplified, downcased, etc...)
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> foo <span class="paren2">(<span class="lisp-bg">x</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren3">(<span class="lisp-bg"><span class="keyword">#:G2021</span> X <span class="keyword">:encoding</span> '<span class="keyword">:utf-8</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg">foreign-string-to-lisp
       <span class="paren4">(<span class="lisp-bg">foreign-funcall <span class="string">"foo"</span> <span class="keyword">:pointer</span> <span class="keyword">#:g2021</span> <span class="keyword">:pointer</span></span>)</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">Again, no generic function overhead.

<h4 class="subheading">Other details</h4>

<p>To short-circuit expansion and use the <code>translate-*</code> functions
instead, simply call the next method.  Return its result in cases
where your method cannot generate an appropriate replacement for it. 
This analogous to the <code>&amp;whole form</code> mechanism compiler macros
provide.

   <p>The <code>expand-*</code> methods have precedence over their
<code>translate-*</code> counterparts and are guaranteed to be used in
<code>defcfun</code>, <code>foreign-funcall</code>, <code>defcvar</code> and
<code>defcallback</code>.  If you define a method on each of the
<code>expand-*</code> generic functions, you are guaranteed to have full
control over the expressions generated for type translation in these
macros.

   <p>They may or may not be used in other <acronym>CFFI</acronym> operators that need to
translate between Lisp and C data; you may only assume that
<code>expand-*</code> methods will probably only be called during Lisp
compilation.

   <p><code>expand-to-foreign-dyn</code> has precedence over
<code>expand-to-foreign</code> and is only used in <code>defcfun</code> and
<code>foreign-funcall</code>, only making sense in those contexts.

   <p><strong>Important note:</strong> this set of generic functions is called at
macroexpansion time.  Methods are defined when loaded or evaluated,
not compiled.  You are responsible for ensuring that your
<code>expand-*</code> methods are defined when the <code>foreign-funcall</code> or
other forms that use them are compiled.  One way to do this is to put
the method definitions earlier in the file and inside an appropriate
<code>eval-when</code> form; another way is to always load a separate Lisp
or <acronym>FASL</acronym> file containing your <code>expand-*</code> definitions
before compiling files with forms that ought to use them.  Otherwise,
they will not be found and the runtime translators will be used
instead.

<div class="node">
<a name="Foreign-Structure-Types"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Allocating-Foreign-Objects">Allocating Foreign Objects</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Optimizing-Type-Translators">Optimizing Type Translators</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.6 Foreign Structure Types</h3>

<p>For more involved C types than simple aliases to built-in types, such
as you can make with <code>defctype</code>, <acronym>CFFI</acronym> allows declaration of
structures and unions with <code>defcstruct</code> and <code>defcunion</code>.

   <p>For example, consider this fictional C structure declaration holding
some personal information:

<pre class="example">  struct person {
    int number;
    char* reason;
  };
</pre>
   <p class="noindent">The equivalent <code>defcstruct</code> form follows:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> person
    <span class="paren2">(<span class="lisp-bg">number <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">reason <span class="keyword">:string</span></span>)</span></span>)</span>
</pre>
   <!-- LMH structure translation -->
   <p>By default, <a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> (and also <a href="#mem_002dref">mem-ref</a>) will
make a plist with slot names as keys, and <a href="#convert_002dto_002dforeign">convert-to-foreign</a> will
translate such a plist to a foreign structure.  A user wishing to define
other translations should use the <code>:class</code> argument to
<a href="#defcstruct">defcstruct</a>, and then define methods for
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> and
<a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a> that specialize on this class,
possibly calling <code>call-next-method</code> to translate from and to the
plists rather than provide a direct interface to the foreign object. 
The macro <code>translation-forms-for-class</code> will generate the forms
necessary to translate a Lisp class into a foreign structure and vice
versa. 
<!-- Write separate function doc section for translation-forms-for-class? -->
<!-- Examples, perhaps taken from the tests? -->

   <p>Please note that this interface is only for those that must know about
the values contained in a relevant struct.  If the library you are
interfacing returns an opaque pointer that needs only be passed to
other C library functions, by all means just use <code>:pointer</code> or a
type-safe definition munged together with <code>defctype</code> and type
translation.  To pass or return a structure by value to a function, load
the cffi-libffi system and specify the structure as <code>(:struct
</code><var>structure-name</var><code>)</code>.  To pass or return the pointer, you can use
either <code>:pointer</code> or <code>(:pointer (:struct
</code><var>structure-name</var><code>))</code>.

   <p><em>Compatibility note:</em> Previous versions of CFFI accepted the
&ldquo;bare&rdquo; <var>structure-name</var> as a type specification, which was
interpreted as a pointer to the structure.  This is deprecated and
produces a style warning.  Using this deprecated form means that
<a href="#mem_002daref">mem-aref</a> retains its prior meaning and returns a pointer.  Using
the <code>(:struct </code><var>structure-name</var><code>)</code> form for the type,
<a href="#mem_002daref">mem-aref</a> provides a Lisp object translated from the
structure (by default a plist).  Thus the semantics are consistent with all
types in returning the object as represented in Lisp, and not a pointer,
with the exception of the &ldquo;bare&rdquo; structure compatibility retained. 
In order to obtain the pointer, you should use the function <a href="#mem_002daptr">mem-aptr</a>.

   <p>See <a href="#defcstruct">defcstruct</a> for more details.

<div class="node">
<a name="Allocating-Foreign-Objects"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#convert_002dfrom_002dforeign">convert-from-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Foreign-Structure-Types">Foreign Structure Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="section">6.7 Allocating Foreign Objects</h3>

<!-- I moved this because I moved with-foreign-object to the Pointers -->
<!-- chapter, where foreign-alloc is. -->
<p>See <a href="#Allocating-Foreign-Memory">Allocating Foreign Memory</a>.

<!-- =================================================================== -->
<!-- CONVERT-FROM-FOREIGN -->
<div class="node">
<a name="convert-from-foreign"></a>
<a name="convert_002dfrom_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#convert_002dto_002dforeign">convert-to-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Allocating-Foreign-Objects">Allocating Foreign Objects</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">convert-from-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>convert-from-foreign</b><var> foreign-value type &rArr; value<a name="index-convert_002dfrom_002dforeign-76"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-value</var><dd>The primitive C value as returned from a primitive foreign function or
from <code>convert-to-foreign</code>.

     <br><dt><var>type</var><dd>A <acronym>CFFI</acronym> type specifier.

     <br><dt><var>value</var><dd>The Lisp value translated from <var>foreign-value</var>. 
</dl>

<h4 class="subheading">Description</h4>

<p>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.

   <p>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.

   <p>Its behavior is better described under <code>translate-from-foreign</code>'s
documentation.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"a boat"</span> <span class="keyword">:string</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
  =&gt; T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-from-foreign * <span class="keyword">:string</span></span>)</span>
  =&gt; "a boat"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#convert_002dto_002dforeign">convert-to-foreign</a> <br>
<a href="#free_002dconverted_002dobject">free-converted-object</a> <br>
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a>

<!-- =================================================================== -->
<!-- CONVERT-TO-FOREIGN -->
<div class="node">
<a name="convert-to-foreign"></a>
<a name="convert_002dto_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defbitfield">defbitfield</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#convert_002dfrom_002dforeign">convert-from-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">convert-to-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>convert-to-foreign</b><var> value type &rArr; foreign-value, alloc-params<a name="index-convert_002dto_002dforeign-77"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>value</var><dd>The Lisp object to be translated to a foreign object.

     <br><dt><var>type</var><dd>A <acronym>CFFI</acronym> type specifier.

     <br><dt><var>foreign-value</var><dd>The primitive C value, ready to be passed to a primitive foreign
function.

     <br><dt><var>alloc-params</var><dd>Something of a translation state; you must pass it to
<code>free-converted-object</code> along with the foreign value for that to
work. 
</dl>

<h4 class="subheading">Description</h4>

<p>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.

   <p>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.

   <p>Its behavior is better described under <code>translate-to-foreign</code>'s
documentation.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign t <span class="keyword">:boolean</span></span>)</span>
  =&gt; 1
  =&gt; NIL
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"hello, world"</span> <span class="keyword">:string</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x097C5F80&gt;
  =&gt; T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">code-char <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:char</span> 5</span>)</span></span>)</span>
  =&gt; #\,
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <br>
<a href="#free_002dconverted_002dobject">free-converted-object</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a>

<!-- =================================================================== -->
<!-- DEFBITFIELD -->
<div class="node">
<a name="defbitfield"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defcstruct">defcstruct</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#convert_002dto_002dforeign">convert-to-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">defbitfield</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defbitfield</b><var> name-and-options &amp;body masks<a name="index-defbitfield-78"></a></var><br>
     </div>

   <p>masks ::= [docstring] { (symbol value) }* <br>
name-and-options ::= name | (name &amp;optional (base-type :int))

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>The name of the new bitfield type.

     <br><dt><var>docstring</var><dd>A documentation string, ignored.

     <br><dt><var>base-type</var><dd>A symbol denoting a foreign type.

     <br><dt><var>symbol</var><dd>A Lisp symbol.

     <br><dt><var>value</var><dd>An integer representing a bitmask. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defbitfield</code> macro is used to define foreign types that map
lists of symbols to integer values.

   <p>If <var>value</var> is omitted, it will be computed as follows: find the
greatest <var>value</var> previously used, including those so computed,
with only a single 1-bit in its binary representation (that is, powers
of two), and left-shift it by one.  This rule guarantees that a
computed <var>value</var> cannot clash with previous values, but may clash
with future explicitly specified values.

   <p>Symbol lists will be automatically converted to values and vice versa
when being passed as arguments to or returned from foreign functions,
respectively. The same applies to any other situations where an object
of a bitfield type is expected.

   <p>Types defined with <code>defbitfield</code> canonicalize to <var>base-type</var>
which is <code>:int</code> by default.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> open-flags
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:rdonly</span> #x0000</span>)</span>
    <span class="keyword">:wronly</span>               <span class="comment">;#x0001
  </span>  <span class="keyword">:rdwr</span>                 <span class="comment">;...
  </span>  <span class="keyword">:nonblock</span>
    <span class="keyword">:append</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:creat</span>  #x0200</span>)</span></span>)</span>
    ;; etc...
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-symbols 'open-flags #b1101</span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="keyword">:RDONLY</span> <span class="keyword">:WRONLY</span> <span class="keyword">:NONBLOCK</span> <span class="keyword">:APPEND</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-value 'open-flags '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:rdwr</span> <span class="keyword">:creat</span></span>)</span></span>)</span>
  =&gt; 514   ; #x0202
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"open"</span> unix-open</span>)</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">path <span class="keyword">:string</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">flags open-flags</span>)</span>
    <span class="paren2">(<span class="lisp-bg">mode <span class="keyword">:uint16</span></span>)</span></span>)</span> ; unportable
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">unix-open <span class="string">"/tmp/foo"</span> '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:wronly</span> <span class="keyword">:creat</span></span>)</span> #o644</span>)</span>
  =&gt; #&lt;an fd&gt;
   
  <span class="comment">;;; Consider also the following lispier wrapper around open()
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> lispier-open <span class="paren2">(<span class="lisp-bg">path mode &amp;rest flags</span>)</span>
    <span class="paren2">(<span class="lisp-bg">unix-open path flags mode</span>)</span></span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a> <br>
<a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>

<!-- =================================================================== -->
<!-- DEFCSTRUCT -->
<div class="node">
<a name="defcstruct"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defcunion">defcunion</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defbitfield">defbitfield</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">defcstruct</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcstruct</b><var> name-and-options &amp;body doc-and-slots &rArr; name<a name="index-defcstruct-79"></a></var><br>
     </div>

   <p>name-and-options ::= structure-name | (structure-name &amp;key size)

   <p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count offset) }*

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>structure-name</var><dd>The name of new structure type.

     <br><dt><var>docstring</var><dd>A documentation string, ignored.

     <br><dt><var>slot-name</var><dd>A symbol naming the slot.  It must be unique among slot names in this
structure.

     <br><dt><var>size</var><dd>Use this option to override the size (in bytes) of the struct.

     <br><dt><var>slot-type</var><dd>The type specifier for the slot.

     <br><dt><var>count</var><dd>Used to declare an array of size <var>count</var> inside the
structure.  Defaults to <code>1</code> as such an array and a single element
are semantically equivalent.

     <br><dt><var>offset</var><dd>Overrides the slot's offset. The next slot's offset is calculated
based on this one. 
</dl>

<h4 class="subheading">Description</h4>

<p>This defines a new <acronym>CFFI</acronym> aggregate type akin to C <code>struct</code>s. 
In other words, it specifies that foreign objects of the type
<var>structure-name</var> are groups of different pieces of data, or
&ldquo;slots&rdquo;, of the <var>slot-type</var>s, distinguished from each other by
the <var>slot-name</var>s.  Each structure is located in memory at a
position, and the slots are allocated sequentially beginning at that
point in memory (with some padding allowances as defined by the C
<acronym>ABI</acronym>, unless otherwise requested by specifying an
<var>offset</var> from the beginning of the structure (offset 0).

   <p>In other words, it is isomorphic to the C <code>struct</code>, giving
several extra features.

   <p>There are two kinds of slots, for the two kinds of <acronym>CFFI</acronym> types:

     <dl>
<dt><dfn>Simple</dfn><dd>Contain a single instance of a type that canonicalizes to a built-in
type, such as <code>:long</code> or <code>:pointer</code>.  Used for simple
<acronym>CFFI</acronym> types.

     <br><dt><dfn>Aggregate</dfn><dd>Contain an embedded structure or union, or an array of objects.  Used
for aggregate <acronym>CFFI</acronym> types. 
</dl>

   <p>The use of <acronym>CLOS</acronym> terminology for the structure-related
features is intentional; structure definitions are very much like
classes with (far) fewer features.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Point structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr 'point</span>)</span>
          <span class="comment">;; Initialize the slots
  </span>        <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr 'point 'x</span>)</span> 42
                <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr 'point 'y</span>)</span> 42</span>)</span>
          <span class="comment">;; Return a list with the coordinates
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x y</span>)</span> ptr point</span>)</span>
            <span class="paren3">(<span class="lisp-bg">list x y</span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">42 42</span>)</span>
</pre>
<pre class="lisp">  <span class="comment">;; Using the :size and :offset options to define a partial structure.
  </span><span class="comment">;; (this is useful when you are interested in only a few slots
  </span><span class="comment">;; of a big foreign structure)
  </span> 
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> <span class="paren2">(<span class="lisp-bg">foo <span class="keyword">:size</span> 32</span>)</span>
    <span class="string">"Some struct with 32 bytes."</span>
                          <span class="comment">; &lt;16 bytes we don't care about&gt;
  </span>  <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span> <span class="keyword">:offset</span> 16</span>)</span>   <span class="comment">; an int at offset 16
  </span>  <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span>              <span class="comment">; another int at offset 16+sizeof(int)
  </span>                        <span class="comment">; &lt;a couple more bytes we don't care about&gt;
  </span>  <span class="paren2">(<span class="lisp-bg">z <span class="keyword">:char</span> <span class="keyword">:offset</span> 24</span>)</span></span>)</span> ; a char at offset 24
                          ; &lt;7 more bytes ignored <span class="paren1">(<span class="lisp-bg">since size is 32</span>)</span>&gt;
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size 'foo</span>)</span>
  =&gt; 32
</pre>
   <pre class="lisp">  ;;; Using :count to define arrays inside of a struct.
  (defcstruct video_tuner
    (name :char :count 32))
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#with_002dforeign_002dslots">with-foreign-slots</a>

<!-- =================================================================== -->
<!-- DEFCUNION -->
<div class="node">
<a name="defcunion"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defctype">defctype</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcstruct">defcstruct</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">defcunion</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcunion</b><var> name &amp;body doc-and-slots &rArr; name<a name="index-defcunion-80"></a></var><br>
     </div>

   <p>doc-and-slots ::= [docstring] { (slot-name slot-type &amp;key count) }*

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>The name of new union type.

     <br><dt><var>docstring</var><dd>A documentation string, ignored.

     <br><dt><var>slot-name</var><dd>A symbol naming the slot.

     <br><dt><var>slot-type</var><dd>The type specifier for the slot.

     <br><dt><var>count</var><dd>Used to declare an array of size <var>count</var> inside the
structure. 
</dl>

<h4 class="subheading">Description</h4>

<p>A union is a structure in which all slots have an offset of zero.  It
is isomorphic to the C <code>union</code>.  Therefore, you should use the
usual foreign structure operations for accessing a union's slots.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcunion</span></i> uint32-bytes
    <span class="paren2">(<span class="lisp-bg">int-value <span class="keyword">:unsigned-int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">bytes <span class="keyword">:unsigned-char</span> <span class="keyword">:count</span> 4</span>)</span></span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>

<!-- =================================================================== -->
<!-- DEFCTYPE -->
<div class="node">
<a name="defctype"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defcenum">defcenum</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcunion">defcunion</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">defctype</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defctype</b><var> name base-type &amp;optional documentation<a name="index-defctype-81"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>The name of the new foreign type.

     <br><dt><var>base-type</var><dd>A symbol or a list defining the new type.

     <br><dt><var>documentation</var><dd>A documentation string, currently ignored. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defctype</code> macro provides a mechanism similar to C's
<code>typedef</code> to define new types. The new type inherits
<var>base-type</var>'s translators, if any. There is no way to define
translations for types for types defined with <code>defctype</code>.  For
that, you should use <a href="#define_002dforeign_002dtype">define-foreign-type</a>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> my-string <span class="keyword">:string</span>
    <span class="string">"My own string type."</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defctype</span></i> long-bools <span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span>
    <span class="string">"Booleans that map to C longs."</span></span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#define_002dforeign_002dtype">define-foreign-type</a>

<!-- =================================================================== -->
<!-- DEFCENUM -->
<div class="node">
<a name="defcenum"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#define_002dforeign_002dtype">define-foreign-type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defctype">defctype</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">defcenum</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcenum</b><var> name-and-options &amp;body enum-list<a name="index-defcenum-82"></a></var><br>
     </div>

   <p>enum-list ::= [docstring] { keyword | (keyword value) }*
name-and-options ::= name | (name &amp;optional (base-type :int))

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>The name of the new enum type.

     <br><dt><var>docstring</var><dd>A documentation string, ignored.

     <br><dt><var>base-type</var><dd>A symbol denoting a foreign type.

     <br><dt><var>keyword</var><dd>A keyword symbol.

     <br><dt><var>value</var><dd>An index value for a keyword. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defcenum</code> macro is used to define foreign types that map
keyword symbols to integer values, similar to the C <code>enum</code> type.

   <p>If <var>value</var> is omitted its value will either be 0, if it's the
first entry, or it it will continue the progression from the last
specified value.

   <p>Keywords will be automatically converted to values and vice-versa when
being passed as arguments to or returned from foreign functions,
respectively. The same applies to any other situations where an object
of an <code>enum</code> type is expected.

   <p>Types defined with <code>defcenum</code> canonicalize to <var>base-type</var>
which is <code>:int</code> by default.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-value 'boolean <span class="keyword">:no</span></span>)</span>
  =&gt; 0
</pre>
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> numbers
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:one</span> 1</span>)</span>
    <span class="keyword">:two</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:four</span> 4</span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-keyword 'numbers 2</span>)</span>
  =&gt; :TWO
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#foreign_002denum_002dvalue">foreign-enum-value</a> <br>
<a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>

<!-- =================================================================== -->
<!-- DEFINE-FOREIGN-TYPE -->
<div class="node">
<a name="define-foreign-type"></a>
<a name="define_002dforeign_002dtype"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#define_002dparse_002dmethod">define-parse-method</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcenum">defcenum</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">define-foreign-type</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>define-foreign-type</b><var> class-name supers slots &amp;rest options &rArr; class-name<a name="index-define_002dforeign_002dtype-83"></a></var><br>
     </div>

   <p>options ::= (<code>:actual-type</code> <var>type</var>) |      (<code>:simple-parser</code> <var>symbol</var>) |      <em>regular defclass option</em>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>class-name</var><dd>A symbol naming the new foreign type class.

     <br><dt><var>supers</var><dd>A list of symbols naming the super classes.

     <br><dt><var>slots</var><dd>A list of slot definitions, passed to <code>defclass</code>. 
</dl>

<h4 class="subheading">Description</h4>

<!-- TODO rewrite -->
<p>The macro <code>define-foreign-type</code> defines a new class
<var>class-name</var>. It is a thin wrapper around <code>defclass</code>. Among
other things, it ensures that <var>class-name</var> becomes a subclass of
<var>foreign-type</var>, what you need to know about that is that there's
an initarg <code>:actual-type</code> which serves the same purpose as
<code>defctype</code>'s <var>base-type</var> argument.

<!-- TODO mention the type translators here -->
<!-- FIX FIX -->
<h4 class="subheading">Examples</h4>

<p>Taken from <acronym>CFFI</acronym>'s <code>:boolean</code> type definition:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> <span class="keyword">:boolean</span> <span class="paren2">(<span class="lisp-bg">&amp;optional <span class="paren3">(<span class="lisp-bg">base-type <span class="keyword">:int</span></span>)</span></span>)</span>
    <span class="string">"Boolean type. Maps to an :int by default. Only accepts integer types."</span>
    <span class="paren2">(<span class="lisp-bg">ecase base-type
      <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">:char</span>
        <span class="keyword">:unsigned-char</span>
        <span class="keyword">:int</span>
        <span class="keyword">:unsigned-int</span>
        <span class="keyword">:long</span>
        <span class="keyword">:unsigned-long</span></span>)</span> base-type</span>)</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type <span class="keyword">:boolean</span></span>)</span>
  =&gt; :INT
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span></span>)</span>
  =&gt; :LONG
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:float</span></span>)</span></span>)</span>
  <span class="comment">;; error--&gt; signalled by ECASE.
  </span>
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#defctype">defctype</a> <br>
<a href="#define_002dparse_002dmethod">define-parse-method</a>

<!-- =================================================================== -->
<!-- DEFINE-PARSE-METHOD -->
<div class="node">
<a name="define-parse-method"></a>
<a name="define_002dparse_002dmethod"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#define_002dforeign_002dtype">define-foreign-type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">define-parse-method</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>define-parse-method</b><var> name lambda-list &amp;body body &rArr; name<a name="index-define_002dparse_002dmethod-84"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type-name</var><dd>A symbol naming the new foreign type.

     <br><dt><var>lambda-list</var><dd>A lambda list which is the argument list of the new foreign type.

     <br><dt><var>body</var><dd>One or more forms that provide a definition of the new foreign type. 
</dl>

<h4 class="subheading">Description</h4>

<!-- TODO: update example. The boolean type is probably a good choice. -->
<h4 class="subheading">Examples</h4>

<p>Taken from <acronym>CFFI</acronym>'s <code>:boolean</code> type definition:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-type</span></i> <span class="keyword">:boolean</span> <span class="paren2">(<span class="lisp-bg">&amp;optional <span class="paren3">(<span class="lisp-bg">base-type <span class="keyword">:int</span></span>)</span></span>)</span>
    <span class="string">"Boolean type. Maps to an :int by default. Only accepts integer types."</span>
    <span class="paren2">(<span class="lisp-bg">ecase base-type
      <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg"><span class="keyword">:char</span>
        <span class="keyword">:unsigned-char</span>
        <span class="keyword">:int</span>
        <span class="keyword">:unsigned-int</span>
        <span class="keyword">:long</span>
        <span class="keyword">:unsigned-long</span></span>)</span> base-type</span>)</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type <span class="keyword">:boolean</span></span>)</span>
  =&gt; :INT
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:long</span></span>)</span></span>)</span>
  =&gt; :LONG
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">canonicalize-foreign-type '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:boolean</span> <span class="keyword">:float</span></span>)</span></span>)</span>
  <span class="comment">;; error--&gt; signalled by ECASE.
  </span>
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#define_002dforeign_002dtype">define-foreign-type</a>

<!-- =================================================================== -->
<!-- EXPLAIN-FOREIGN-SLOT-VALUE -->
<!-- @node explain-foreign-slot-value -->
<!-- @heading explain-foreign-slot-value -->
<!-- @subheading Syntax -->
<!-- @Macro{explain-foreign-slot-value ptr type &rest slot-names} -->
<!-- @subheading Arguments and Values -->
<!-- @table @var -->
<!-- @item ptr -->
<!-- ... -->
<!-- @item type -->
<!-- ... -->
<!-- @item slot-names -->
<!-- ... -->
<!-- @end table -->
<!-- @subheading Description -->
<!-- This macro translates the slot access that would occur by calling -->
<!-- @code{foreign-slot-value} with the same arguments into an equivalent -->
<!-- expression in C and prints it to @code{*standard-output*}. -->
<!-- @emph{Note: this is not implemented yet.} -->
<!-- @subheading Examples -->
<!-- @lisp -->
<!-- CFFI> (explain-foreign-slot-value ptr 'timeval 'tv-secs) -->
<!-- @result{} ptr->tv_secs -->
<!-- CFFI> (explain-foreign-slot-value emp 'employee 'hire-date 'tv-usecs) -->
<!-- @result{} emp->hire_date.tv_usecs -->
<!-- @end lisp -->
<!-- @subheading See Also -->
<!-- =================================================================== -->
<!-- FOREIGN-BITFIELD-SYMBOLS -->
<div class="node">
<a name="foreign-bitfield-symbols"></a>
<a name="foreign_002dbitfield_002dsymbols"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#define_002dparse_002dmethod">define-parse-method</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-bitfield-symbols</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-bitfield-symbols</b><var> type value &rArr; symbols<a name="index-foreign_002dbitfield_002dsymbols-85"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A bitfield type.

     <br><dt><var>value</var><dd>An integer.

     <br><dt><var>symbols</var><dd>A potentially shared list of symbols. 
<code>nil</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-bitfield-symbols</code> returns a possibly shared
list of symbols that correspond to <var>value</var> in <var>type</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> flags
    <span class="paren2">(<span class="lisp-bg">flag-a 1</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-b 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-c 4</span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-symbols 'boolean #b101</span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">FLAG-A FLAG-C</span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defbitfield">defbitfield</a> <br>
<a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>

<!-- =================================================================== -->
<!-- FOREIGN-BITFIELD-VALUE -->
<div class="node">
<a name="foreign-bitfield-value"></a>
<a name="foreign_002dbitfield_002dvalue"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-bitfield-value</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-bitfield-value</b><var> type symbols &rArr; value<a name="index-foreign_002dbitfield_002dvalue-86"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A <code>bitfield</code> type.

     <br><dt><var>symbol</var><dd>A Lisp symbol.

     <br><dt><var>value</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-bitfield-value</code> returns the <var>value</var> that
corresponds to the symbols in the <var>symbols</var> list.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defbitfield</span></i> flags
    <span class="paren2">(<span class="lisp-bg">flag-a 1</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-b 2</span>)</span>
    <span class="paren2">(<span class="lisp-bg">flag-c 4</span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-bitfield-value 'flags '<span class="paren2">(<span class="lisp-bg">flag-a flag-c</span>)</span></span>)</span>
  =&gt; 5  ; #b101
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defbitfield">defbitfield</a> <br>
<a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a>

<!-- =================================================================== -->
<!-- FOREIGN-ENUM-KEYWORD -->
<div class="node">
<a name="foreign-enum-keyword"></a>
<a name="foreign_002denum_002dkeyword"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002denum_002dvalue">foreign-enum-value</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-enum-keyword</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-enum-keyword</b><var> type value &amp;key errorp &rArr; keyword<a name="index-foreign_002denum_002dkeyword-87"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>An <code>enum</code> type.

     <br><dt><var>value</var><dd>An integer.

     <br><dt><var>errorp</var><dd>If true (the default), signal an error if <var>value</var> is not defined
in <var>type</var>.  If false, <code>foreign-enum-keyword</code> returns
<code>nil</code>.

     <br><dt><var>keyword</var><dd>A keyword symbol. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-enum-keyword</code> returns the keyword symbol
that corresponds to <var>value</var> in <var>type</var>.

   <p>An error is signaled if <var>type</var> doesn't contain such <var>value</var>
and <var>errorp</var> is true.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-keyword 'boolean 1</span>)</span>
  =&gt; :YES
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcenum">defcenum</a> <br>
<a href="#foreign_002denum_002dvalue">foreign-enum-value</a>

<!-- =================================================================== -->
<!-- FOREIGN-ENUM-VALUE -->
<div class="node">
<a name="foreign-enum-value"></a>
<a name="foreign_002denum_002dvalue"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dslot_002dnames">foreign-slot-names</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-enum-value</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-enum-value</b><var> type keyword &amp;key errorp &rArr; value<a name="index-foreign_002denum_002dvalue-88"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>An <code>enum</code> type.

     <br><dt><var>keyword</var><dd>A keyword symbol.

     <br><dt><var>errorp</var><dd>If true (the default), signal an error if <var>keyword</var> is not
defined in <var>type</var>.  If false, <code>foreign-enum-value</code> returns
<code>nil</code>.

     <br><dt><var>value</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-enum-value</code> returns the <var>value</var> that
corresponds to <var>keyword</var> in <var>type</var>.

   <p>An error is signaled if <var>type</var> doesn't contain such
<var>keyword</var>, and <var>errorp</var> is true.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcenum</span></i> boolean
    <span class="keyword">:no</span>
    <span class="keyword">:yes</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-enum-value 'boolean <span class="keyword">:yes</span></span>)</span>
  =&gt; 1
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcenum">defcenum</a> <br>
<a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-NAMES -->
<div class="node">
<a name="foreign-slot-names"></a>
<a name="foreign_002dslot_002dnames"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dslot_002doffset">foreign-slot-offset</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002denum_002dvalue">foreign-enum-value</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-slot-names</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-slot-names</b><var> type &rArr; names<a name="index-foreign_002dslot_002dnames-89"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A foreign struct type.

     <br><dt><var>names</var><dd>A list. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-slot-names</code> returns a potentially shared
list of slot <var>names</var> for the given structure <var>type</var>. This list
has no particular order.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> timeval
    <span class="paren2">(<span class="lisp-bg">tv-secs <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">tv-usecs <span class="keyword">:long</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-names '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">TV-SECS TV-USECS</span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-OFFSET -->
<div class="node">
<a name="foreign-slot-offset"></a>
<a name="foreign_002dslot_002doffset"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dslot_002dnames">foreign-slot-names</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-slot-offset</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-slot-offset</b><var> type slot-name &rArr; offset<a name="index-foreign_002dslot_002doffset-90"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A foreign struct type.

     <br><dt><var>slot-name</var><dd>A symbol.

     <br><dt><var>offset</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-slot-offset</code> returns the <var>offset</var> in
bytes of a slot in a foreign struct type.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> timeval
    <span class="paren2">(<span class="lisp-bg">tv-secs <span class="keyword">:long</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">tv-usecs <span class="keyword">:long</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-offset '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span> 'tv-secs</span>)</span>
  =&gt; 0
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-slot-offset '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> timeval</span>)</span> 'tv-usecs</span>)</span>
  =&gt; 4
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-POINTER -->
<div class="node">
<a name="foreign-slot-pointer"></a>
<a name="foreign_002dslot_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dslot_002dvalue">foreign-slot-value</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dslot_002doffset">foreign-slot-offset</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-slot-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-slot-pointer</b><var> ptr type slot-name &rArr; pointer<a name="index-foreign_002dslot_002dpointer-91"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A pointer to a structure.

     <br><dt><var>type</var><dd>A foreign structure type.

     <br><dt><var>slot-names</var><dd>A slot name in the <var>type</var>.

     <br><dt><var>pointer</var><dd>A pointer to the slot <var>slot-name</var>. 
</dl>

<h4 class="subheading">Description</h4>

<p>Returns a pointer to the location of the slot <var>slot-name</var> in a
foreign object of type <var>type</var> at <var>ptr</var>. The returned pointer
points inside the structure. Both the pointer and the memory it points
to have the same extent as <var>ptr</var>.

   <p>For aggregate slots, this is the same value returned by
<code>foreign-slot-value</code>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Pointer structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-slot-pointer ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'x</span>)</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #xBFFF6E60&gt;
  <span class="comment">;; Note: the exact pointer representation varies from lisp to lisp.
  </span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a>

<!-- =================================================================== -->
<!-- FOREIGN-SLOT-VALUE -->
<div class="node">
<a name="foreign-slot-value"></a>
<a name="foreign_002dslot_002dvalue"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-slot-value</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Accessor: <b>foreign-slot-value</b><var> ptr type slot-name &rArr; object<a name="index-foreign_002dslot_002dvalue-92"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A pointer to a structure.

     <br><dt><var>type</var><dd>A foreign structure type.

     <br><dt><var>slot-name</var><dd>A symbol naming a slot in the structure type.

     <br><dt><var>object</var><dd>The object contained in the slot specified by <var>slot-name</var>. 
</dl>

<h4 class="subheading">Description</h4>

<p>For simple slots, <code>foreign-slot-value</code> returns the value of the
object, such as a Lisp integer or pointer. In C, this would be
expressed as <code>ptr-&gt;slot</code>.

   <p>For aggregate slots, a pointer inside the structure to the beginning
of the slot's data is returned. In C, this would be expressed as
<code>&amp;ptr-&gt;slot</code>. This pointer and the memory it points to have the
same extent as <var>ptr</var>.

   <p>There are compiler macros for <code>foreign-slot-value</code> and its
<code>setf</code> expansion that open code the memory access when
<var>type</var> and <var>slot-names</var> are constant at compile-time.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> point
    <span class="string">"Pointer structure."</span>
    <span class="paren2">(<span class="lisp-bg">x <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">y <span class="keyword">:int</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">ptr '<span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
          <span class="comment">;; Initialize the slots
  </span>        <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr '<span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'x</span>)</span> 42
                <span class="paren3">(<span class="lisp-bg">foreign-slot-value ptr '<span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span> 'y</span>)</span> 42</span>)</span>
          <span class="comment">;; Return a list with the coordinates
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x y</span>)</span> ptr <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> point</span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg">list x y</span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">42 42</span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#foreign_002dslot_002dnames">foreign-slot-names</a> <br>
<a href="#foreign_002dslot_002doffset">foreign-slot-offset</a> <br>
<a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a> <br>
<a href="#with_002dforeign_002dslots">with-foreign-slots</a>

<!-- =================================================================== -->
<!-- FOREIGN-TYPE-ALIGNMENT -->
<div class="node">
<a name="foreign-type-alignment"></a>
<a name="foreign_002dtype_002dalignment"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dtype_002dsize">foreign-type-size</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dslot_002dvalue">foreign-slot-value</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-type-alignment</h3>

<h4 class="subheading">Syntax</h4>

<!-- XXX: This is actually a generic function. -->
<div class="defun">
&mdash; Function: <b>foreign-type-alignment</b><var> type &rArr; alignment<a name="index-foreign_002dtype_002dalignment-93"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A foreign type.

     <br><dt><var>alignment</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-type-alignment</code> returns the
<var>alignment</var> of <var>type</var> in bytes.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:char</span></span>)</span>
  =&gt; 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:short</span></span>)</span>
  =&gt; 2
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment <span class="keyword">:int</span></span>)</span>
  =&gt; 4
</pre>
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> foo
    <span class="paren2">(<span class="lisp-bg">a <span class="keyword">:char</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-alignment '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> foo</span>)</span></span>)</span>
  =&gt; 1
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dtype_002dsize">foreign-type-size</a>

<!-- =================================================================== -->
<!-- FOREIGN-TYPE-SIZE -->
<div class="node">
<a name="foreign-type-size"></a>
<a name="foreign_002dtype_002dsize"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#free_002dconverted_002dobject">free-converted-object</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">foreign-type-size</h3>

<h4 class="subheading">Syntax</h4>

<!-- XXX: this is actually a generic function. -->
<div class="defun">
&mdash; Function: <b>foreign-type-size</b><var> type &rArr; size<a name="index-foreign_002dtype_002dsize-94"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A foreign type.

     <br><dt><var>size</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-type-size</code> return the <var>size</var> of
<var>type</var> in bytes.  This includes any padding within and following
the in-memory representation as needed to create an array of
<var>type</var> objects.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> foo
    <span class="paren2">(<span class="lisp-bg">a <span class="keyword">:double</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">c <span class="keyword">:char</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size <span class="keyword">:double</span></span>)</span>
  =&gt; 8
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size <span class="keyword">:char</span></span>)</span>
  =&gt; 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-type-size '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:struct</span> foo</span>)</span></span>)</span>
  =&gt; 16
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a>

<!-- =================================================================== -->
<!-- FREE-CONVERTED-OBJECT -->
<div class="node">
<a name="free-converted-object"></a>
<a name="free_002dconverted_002dobject"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#free_002dtranslated_002dobject">free-translated-object</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dtype_002dsize">foreign-type-size</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">free-converted-object</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>free-converted-object</b><var> foreign-value type params<a name="index-free_002dconverted_002dobject-95"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-value</var><dd>The C object to be freed.

     <br><dt><var>type</var><dd>A <acronym>CFFI</acronym> type specifier.

     <br><dt><var>params</var><dd>The state returned as the second value from <code>convert-to-foreign</code>;
used to implement the third argument to <code>free-translated-object</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The return value is unspecified.

   <p>This is an external interface to the type translation facility.  In
the implementation, all foreign functions are ultimately defined as
type translation wrappers around primitive foreign function
invocations.

   <p>This function is available mostly for inspection of the type
translation process, and possibly optimization of special cases of
your foreign function calls.

   <p>Its behavior is better described under <code>free-translated-object</code>'s
documentation.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">convert-to-foreign <span class="string">"a boat"</span> <span class="keyword">:string</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x097ACDC0&gt;
  =&gt; T
  CFFI-USER&gt; <span class="paren1">(<span class="lisp-bg">free-converted-object * <span class="keyword">:string</span> t</span>)</span>
  =&gt; NIL
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#convert_002dfrom_002dforeign">convert-from-foreign</a> <br>
<a href="#convert_002dto_002dforeign">convert-to-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>

<!-- =================================================================== -->
<!-- FREE-TRANSLATED-OBJECT -->
<!-- TODO: update -->
<div class="node">
<a name="free-translated-object"></a>
<a name="free_002dtranslated_002dobject"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dfrom_002dforeign">translate-from-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#free_002dconverted_002dobject">free-converted-object</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">free-translated-object</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Generic Function: <b>free-translated-object</b><var> value type-name param<a name="index-free_002dtranslated_002dobject-96"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>pointer</var><dd>The foreign value returned by <code>translate-to-foreign</code>.

     <br><dt><var>type-name</var><dd>A symbol naming a foreign type defined by <code>defctype</code>.

     <br><dt><var>param</var><dd>The second value, if any, returned by <code>translate-to-foreign</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>This generic function may be specialized by user code to perform
automatic deallocation of foreign objects as they are passed to C
functions.

   <p>Any methods defined on this generic function must EQL-specialize the
<var>type-name</var> parameter on a symbol defined as a foreign type by
the <code>defctype</code> macro.

<h4 class="subheading">See Also</h4>

<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a>

<!-- =================================================================== -->
<!-- TRANSLATE-FROM-FOREIGN -->
<!-- TODO: update -->
<div class="node">
<a name="translate-from-foreign"></a>
<a name="translate_002dfrom_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dto_002dforeign">translate-to-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#free_002dtranslated_002dobject">free-translated-object</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">translate-from-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Generic Function: <b>translate-from-foreign</b><var> foreign-value type-name &rArr; lisp-value<a name="index-translate_002dfrom_002dforeign-97"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-value</var><dd>The foreign value to convert to a Lisp object.

     <br><dt><var>type-name</var><dd>A symbol naming a foreign type defined by <code>defctype</code>.

     <br><dt><var>lisp-value</var><dd>The lisp value to pass in place of <code>foreign-value</code> to Lisp code. 
</dl>

<h4 class="subheading">Description</h4>

<p>This generic function is invoked by <acronym>CFFI</acronym> to convert a foreign value to
a Lisp value, such as when returning from a foreign function, passing
arguments to a callback function, or accessing a foreign variable.

   <p>To extend the <acronym>CFFI</acronym> type system by performing custom translations, this
method may be specialized by <span class="sc">eql</span>-specializing <code>type-name</code> on a
symbol naming a foreign type defined with <code>defctype</code>.  This
method should return the appropriate Lisp value to use in place of the
foreign value.

   <p>The results are undefined if the <code>type-name</code> parameter is
specialized in any way except an <span class="sc">eql</span> specializer on a foreign type
defined with <code>defctype</code>.  Specifically, translations may not be
defined for built-in types.

<h4 class="subheading">See Also</h4>

<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dto_002dforeign">translate-to-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>

<!-- =================================================================== -->
<!-- TRANSLATE-TO-FOREIGN -->
<!-- TODO: update -->
<div class="node">
<a name="translate-to-foreign"></a>
<a name="translate_002dto_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dfrom_002dforeign">translate-from-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">translate-to-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Generic Function: <b>translate-to-foreign</b><var> lisp-value type-name &rArr; foreign-value, alloc-param<a name="index-translate_002dto_002dforeign-98"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>lisp-value</var><dd>The Lisp value to convert to foreign representation.

     <br><dt><var>type-name</var><dd>A symbol naming a foreign type defined by <code>defctype</code>.

     <br><dt><var>foreign-value</var><dd>The foreign value to pass in place of <code>lisp-value</code> to foreign code.

     <br><dt><var>alloc-param</var><dd>If present, this value will be passed to
<code>free-translated-object</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>This generic function is invoked by <acronym>CFFI</acronym> to convert a Lisp value to a
foreign value, such as when passing arguments to a foreign function,
returning a value from a callback, or setting a foreign variable.  A
&ldquo;foreign value&rdquo; is one appropriate for passing to the next-lowest
translator, including the low-level translators that are ultimately
invoked invisibly with <acronym>CFFI</acronym>.

   <p>To extend the <acronym>CFFI</acronym> type system by performing custom translations, this
method may be specialized by <span class="sc">eql</span>-specializing <code>type-name</code> on a
symbol naming a foreign type defined with <code>defctype</code>.  This
method should return the appropriate foreign value to use in place of
the Lisp value.

   <p>In cases where <acronym>CFFI</acronym> can determine the lifetime of the foreign object
returned by this method, it will invoke <code>free-translated-object</code>
on the foreign object at the appropriate time.  If
<code>translate-to-foreign</code> returns a second value, it will be passed
as the <code>param</code> argument to <code>free-translated-object</code>.  This
can be used to establish communication between the allocation and
deallocation methods.

   <p>The results are undefined if the <code>type-name</code> parameter is
specialized in any way except an <span class="sc">eql</span> specializer on a foreign type
defined with <code>defctype</code>.  Specifically, translations may not be
defined for built-in types.

<h4 class="subheading">See Also</h4>

<p><a href="#Foreign-Type-Translators">Foreign Type Translators</a> <br>
<a href="#translate_002dfrom_002dforeign">translate-from-foreign</a> <br>
<a href="#free_002dtranslated_002dobject">free-translated-object</a>

<!-- =================================================================== -->
<!-- TRANSLATE-INTO-FOREIGN-MEMORY -->
<div class="node">
<a name="translate-into-foreign-memory"></a>
<a name="translate_002dinto_002dforeign_002dmemory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#with_002dforeign_002dslots">with-foreign-slots</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dto_002dforeign">translate-to-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">translate-into-foreign-memory</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Generic Function: <b>translate-into-foreign-memory</b><var> lisp-value type-name pointer<a name="index-translate_002dinto_002dforeign_002dmemory-99"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>lisp-value</var><dd>The Lisp value to convert to foreign representation.

     <br><dt><var>type-name</var><dd>A symbol or list <code>(:struct </code><var>structure-name</var><code>)</code> naming a foreign type defined by <code>defctype</code>.

     <br><dt><var>pointer</var><dd>The foreign pointer where the translated object should be stored. 
</dl>

<h4 class="subheading">Description</h4>

<p>Translate the Lisp value into the foreign memory location given by
pointer.  The return value is not used.

<!-- =================================================================== -->
<!-- WITH-FOREIGN-SLOTS -->
<div class="node">
<a name="with-foreign-slots"></a>
<a name="with_002dforeign_002dslots"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Foreign-Types">Foreign Types</a>

</div>

<h3 class="heading">with-foreign-slots</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>with-foreign-slots</b> (<var>vars ptr type</var>)<var> &amp;body body<a name="index-with_002dforeign_002dslots-100"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>vars</var><dd>A list of symbols.

     <br><dt><var>ptr</var><dd>A foreign pointer to a structure.

     <br><dt><var>type</var><dd>A structure type.

     <br><dt><var>body</var><dd>A list of forms to be executed. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>with-foreign-slots</code> macro creates local symbol macros for
each var in <var>vars</var> to reference foreign slots in <var>ptr</var> of
<var>type</var>.  It is similar to Common Lisp's <code>with-slots</code> macro.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcstruct</span></i> tm
    <span class="paren2">(<span class="lisp-bg">sec <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">min <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">hour <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">mon  <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">year <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">wday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">yday <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">isdst  <span class="keyword">:boolean</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">zone   <span class="keyword">:string</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">gmtoff <span class="keyword">:long</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">time <span class="keyword">:int</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref time <span class="keyword">:int</span></span>)</span>
                <span class="paren3">(<span class="lisp-bg">foreign-funcall <span class="string">"time"</span> <span class="keyword">:pointer</span> <span class="paren4">(<span class="lisp-bg">null-pointer</span>)</span> <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"gmtime"</span> <span class="keyword">:pointer</span> time <span class="paren3">(<span class="lisp-bg"><span class="keyword">:pointer</span> <span class="paren4">(<span class="lisp-bg"><span class="keyword">:struct</span> tm</span>)</span></span>)</span></span>)</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102A30&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-slots</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">sec min hour mday mon year</span>)</span> * <span class="paren3">(<span class="lisp-bg"><span class="keyword">:struct</span> tm</span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">format nil <span class="string">"~A:~A:~A, ~A/~A/~A"</span>
                  hour min sec <span class="paren3">(<span class="lisp-bg">+ 1900 year</span>)</span> mon mday</span>)</span></span>)</span>
  =&gt; "7:22:47, 2005/8/2"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcstruct">defcstruct</a> <br>
<a href="#defcunion">defcunion</a> <br>
<a href="#foreign_002dslot_002dvalue">foreign-slot-value</a>

<!-- =================================================================== -->
<!-- CHAPTER: Pointers -->
<div class="node">
<a name="Pointers"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Strings">Strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Foreign-Types">Foreign Types</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Pointers</h2>

<p>All C data in <acronym>CFFI</acronym> is referenced through pointers.  This includes
defined C variables that hold immediate values, and integers.

   <p>To see why this is, consider the case of the C integer.  It is not
only an arbitrary representation for an integer, congruent to Lisp's
fixnums; the C integer has a specific bit pattern in memory defined by
the C <acronym>ABI</acronym>.  Lisp has no such constraint on its fixnums;
therefore, it only makes sense to think of fixnums as C integers if
you assume that <acronym>CFFI</acronym> converts them when necessary, such as when
storing one for use in a C function call, or as the value of a C
variable.  This requires defining an area of memory<a rel="footnote" href="#fn-11" name="fnd-11"><sup>11</sup></a>,
represented through an effective address, and storing it there.

   <p>Due to this compartmentalization, it only makes sense to manipulate
raw C data in Lisp through pointers to it.  For example, while there
may be a Lisp representation of a <code>struct</code> that is converted to C
at store time, you may only manipulate its raw data through a pointer. 
The C compiler does this also, albeit informally.

<ul class="menu">
<li><a accesskey="1" href="#Basic-Pointer-Operations">Basic Pointer Operations</a>
<li><a accesskey="2" href="#Allocating-Foreign-Memory">Allocating Foreign Memory</a>
<li><a accesskey="3" href="#Accessing-Foreign-Memory">Accessing Foreign Memory</a>

</li></ul>
<p>Dictionary

</p>
<ul class="menu">
<li><a accesskey="4" href="#foreign_002dfree">foreign-free</a>
<li><a accesskey="5" href="#foreign_002dalloc">foreign-alloc</a>
<li><a accesskey="6" href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a>
<li><a accesskey="7" href="#inc_002dpointer">inc-pointer</a>
<li><a accesskey="8" href="#incf_002dpointer">incf-pointer</a>
<li><a accesskey="9" href="#make_002dpointer">make-pointer</a>
<li><a href="#mem_002daptr">mem-aptr</a>
<li><a href="#mem_002daref">mem-aref</a>
<li><a href="#mem_002dref">mem-ref</a>
<li><a href="#null_002dpointer">null-pointer</a>
<li><a href="#null_002dpointer_002dp">null-pointer-p</a>
<li><a href="#pointerp">pointerp</a>
<li><a href="#pointer_002daddress">pointer-address</a>
<li><a href="#pointer_002deq">pointer-eq</a>
<li><a href="#with_002dforeign_002dobject">with-foreign-object</a>
<li><a href="#with_002dforeign_002dobjects">with-foreign-objects</a>
<li><a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>
</ul>

<div class="node">
<a name="Basic-Pointer-Operations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Allocating-Foreign-Memory">Allocating Foreign Memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointers">Pointers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="section">7.1 Basic Pointer Operations</h3>

<p>Manipulating pointers proper can be accomplished through most of the
other operations defined in the Pointers dictionary, such as
<code>make-pointer</code>, <code>pointer-address</code>, and <code>pointer-eq</code>. 
When using them, keep in mind that they merely manipulate the Lisp
representation of pointers, not the values they point to.

<div class="defun">
&mdash; Lisp Type: <b>foreign-pointer</b><var><a name="index-foreign_002dpointer-101"></a></var><br>
<blockquote><p>The pointers' representations differ from implementation to
implementation and have different types.  <code>foreign-pointer</code>
provides a portable type alias to each of these types. 
</p></blockquote></div>

<div class="node">
<a name="Allocating-Foreign-Memory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Accessing-Foreign-Memory">Accessing Foreign Memory</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Basic-Pointer-Operations">Basic Pointer Operations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="section">7.2 Allocating Foreign Memory</h3>

<p><acronym>CFFI</acronym> provides support for stack and heap C memory allocation. 
Stack allocation, done with <code>with-foreign-object</code>, is sometimes
called &ldquo;dynamic&rdquo; allocation in Lisp, because memory allocated as
such has dynamic extent, much as with <code>let</code> bindings of special
variables.

   <p>This should not be confused with what C calls &ldquo;dynamic&rdquo; allocation,
or that done with <code>malloc</code> and friends.  This sort of heap
allocation is done with <code>foreign-alloc</code>, creating objects that
exist until freed with <code>foreign-free</code>.

<div class="node">
<a name="Accessing-Foreign-Memory"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dfree">foreign-free</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Allocating-Foreign-Memory">Allocating Foreign Memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="section">7.3 Accessing Foreign Memory</h3>

<p>When manipulating raw C data, consider that all pointers are pointing
to an array.  When you only want one C value, such as a single
<code>struct</code>, this array only has one such value.  It is worthwhile
to remember that everything is an array, though, because this is also
the semantic that C imposes natively.

   <p>C values are accessed as the <code>setf</code>-able places defined by
<code>mem-aref</code> and <code>mem-ref</code>.  Given a pointer and a <acronym>CFFI</acronym>
type (see <a href="#Foreign-Types">Foreign Types</a>), either of these will dereference the
pointer, translate the C data there back to Lisp, and return the
result of said translation, performing the reverse operation when
<code>setf</code>-ing.  To decide which one to use, consider whether you
would use the array index operator <code>[</code><var>n</var><code>]</code> or the pointer
dereference <code>*</code> in C; use <code>mem-aref</code> for array indexing and
<code>mem-ref</code> for pointer dereferencing.

<!-- =================================================================== -->
<!-- FOREIGN-FREE -->
<div class="node">
<a name="foreign-free"></a>
<a name="foreign_002dfree"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dalloc">foreign-alloc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Accessing-Foreign-Memory">Accessing Foreign Memory</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">foreign-free</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-free</b><var> ptr &rArr; undefined<a name="index-foreign_002dfree-102"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A foreign pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-free</code> function frees a <code>ptr</code> previously
allocated by <code>foreign-alloc</code>. The consequences of freeing a given
pointer twice are undefined.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x1022E0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-free *</span>)</span>
  =&gt; NIL
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dalloc">foreign-alloc</a> <br>
<a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>

<!-- =================================================================== -->
<!-- FOREIGN-ALLOC -->
<div class="node">
<a name="foreign-alloc"></a>
<a name="foreign_002dalloc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dfree">foreign-free</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">foreign-alloc</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-alloc</b><var> type &amp;key initial-element initial-contents </var>(<var>count 1</var>)<var> null-terminated-p &rArr; pointer<a name="index-foreign_002dalloc-103"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>type</var><dd>A foreign type.

     <br><dt><var>initial-element</var><dd>A Lisp object.

     <br><dt><var>initial-contents</var><dd>A sequence.

     <br><dt><var>count</var><dd>An integer. Defaults to 1 or the length of <var>initial-contents</var> if
supplied.

     <br><dt><var>null-terminated-p</var><dd>A boolean, false by default.

     <br><dt><var>pointer</var><dd>A foreign pointer to the newly allocated memory. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-alloc</code> function allocates enough memory to hold
<var>count</var> objects of type <var>type</var> and returns a
<var>pointer</var>. This memory must be explicitly freed using
<code>foreign-free</code> once it is no longer needed.

   <p>If <var>initial-element</var> is supplied, it is used to initialize the
<var>count</var> objects the newly allocated memory holds.

   <p>If an <var>initial-contents</var> sequence is supplied, it must have a
length less than or equal to <var>count</var> and each of its elements
will be used to initialize the contents of the newly allocated
memory.

   <p>If <var>count</var> is omitted and <var>initial-contents</var> is specified, it
will default to <code>(length </code><var>initial-contents</var><code>)</code>.

   <p><var>initial-element</var> and <var>initial-contents</var> are mutually
exclusive.

   <p>When <var>null-terminated-p</var> is true,
<code>(1+ (max </code><var>count</var><code> (length </code><var>initial-contents</var><code>)))</code> elements
are allocated and the last one is set to <code>NULL</code>. Note that in
this case <var>type</var> must be a pointer type (ie. a type that
canonicalizes to <code>:pointer</code>), otherwise an error is signaled.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102D80&gt;     ; A pointer to 1 byte of memory.
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:char</span> <span class="keyword">:count</span> 20</span>)</span>
  =&gt; #&lt;A Mac Pointer #x1024A0&gt;     ; A pointer to 20 bytes of memory.
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-element</span> 12</span>)</span>
  =&gt; #&lt;A Mac Pointer #x1028B0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref * <span class="keyword">:int</span></span>)</span>
  =&gt; 12
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-contents</span> '<span class="paren2">(<span class="lisp-bg">1 2 3</span>)</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102950&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 3
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:int</span> i</span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">1 2 3</span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span> <span class="keyword">:initial-contents</span> #<span class="paren2">(<span class="lisp-bg">1 2 3</span>)</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102960&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 3
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:int</span> i</span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">1 2 3</span>)</span>
   
  <span class="comment">;;; Allocate a char** pointer that points to newly allocated memory
  </span><span class="comment">;;; by the :string type translator for the string "foo".
  </span>CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:string</span> <span class="keyword">:initial-element</span> <span class="string">"foo"</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102C40&gt;
</pre>
<pre class="lisp">  <span class="comment">;;; Allocate a null-terminated array of strings.
  </span><span class="comment">;;; (Note: FOREIGN-STRING-TO-LISP returns NIL when passed a null pointer)
  </span>CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc <span class="keyword">:string</span>
                       <span class="keyword">:initial-contents</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"baz"</span></span>)</span>
                       <span class="keyword">:null-terminated-p</span> t</span>)</span>
  =&gt; #&lt;A Mac Pointer #x102D20&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 4
              collect <span class="paren2">(<span class="lisp-bg">mem-aref * <span class="keyword">:string</span> i</span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="string">"foo"</span> <span class="string">"bar"</span> <span class="string">"baz"</span> NIL</span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
          <span class="paren2">(<span class="lisp-bg">dotimes <span class="paren3">(<span class="lisp-bg">i 3</span>)</span>
            <span class="paren3">(<span class="lisp-bg">foreign-free <span class="paren4">(<span class="lisp-bg">mem-aref ** <span class="keyword">:pointer</span> i</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-free **</span>)</span></span>)</span>
  =&gt; nil
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dfree">foreign-free</a> <br>
<a href="#with_002dforeign_002dobject">with-foreign-object</a> <br>
<a href="#with_002dforeign_002dpointer">with-foreign-pointer</a>

<!-- =================================================================== -->
<!-- FOREIGN-SYMBOL-POINTER -->
<div class="node">
<a name="foreign-symbol-pointer"></a>
<a name="foreign_002dsymbol_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#inc_002dpointer">inc-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dalloc">foreign-alloc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">foreign-symbol-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-symbol-pointer</b><var> foreign-name &amp;key library &rArr; pointer<a name="index-foreign_002dsymbol_002dpointer-104"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-name</var><dd>A string.

     <br><dt><var>pointer</var><dd>A foreign pointer, or <code>nil</code>.

     <br><dt><var>library</var><dd>A Lisp symbol or an instance of <code>foreign-library</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>foreign-symbol-pointer</code> will return a foreign
pointer corresponding to the foreign symbol denoted by the string
<var>foreign-name</var>.  If a foreign symbol named <var>foreign-name</var>
doesn't exist, <code>nil</code> is returned.

   <p>ABI name manglings will be performed on <var>foreign-name</var> by
<code>foreign-symbol-pointer</code> if necessary. (eg: adding a leading
underscore on darwin/ppc)

   <p><var>library</var> should name a foreign library as defined by
<code>define-foreign-library</code>, <code>:default</code> (which is the default)
or an instance of <code>foreign-library</code> as returned by
<code>load-foreign-library</code>.

   <p><strong>Important note:</strong> do not keep these pointers across saved Lisp
cores as the foreign-library may move across sessions.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"errno"</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #xA0008130&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"strerror"</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x9002D0F8&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall-pointer * <span class="paren2">(<span class="lisp-bg"></span>)</span> <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg">mem-ref ** <span class="keyword">:int</span></span>)</span> <span class="keyword">:string</span></span>)</span>
  =&gt; "No such file or directory"
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"inexistent symbol"</span></span>)</span>
  =&gt; NIL
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcvar">defcvar</a>

<!-- =================================================================== -->
<!-- INC-POINTER -->
<div class="node">
<a name="inc-pointer"></a>
<a name="inc_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#incf_002dpointer">incf-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">inc-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>inc-pointer</b><var> pointer offset &rArr; new-pointer<a name="index-inc_002dpointer-105"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>pointer</var><dt><var>new-pointer</var><dd>A foreign pointer.

     <br><dt><var>offset</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>inc-pointer</code> will return a <var>new-pointer</var> pointing
<var>offset</var> bytes past <var>pointer</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Common Lisp"</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x102EA0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">inc-pointer * 7</span>)</span>
  =&gt; #&lt;A Mac Pointer #x102EA7&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp *</span>)</span>
  =&gt; "Lisp"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#incf_002dpointer">incf-pointer</a> <br>
<a href="#make_002dpointer">make-pointer</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a>

<!-- =================================================================== -->
<!-- INCF-POINTER -->
<div class="node">
<a name="incf-pointer"></a>
<a name="incf_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#make_002dpointer">make-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#inc_002dpointer">inc-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">incf-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>incf-pointer</b><var> place &amp;optional </var>(<var>offset 1</var>)<var> &rArr; new-pointer<a name="index-incf_002dpointer-106"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>place</var><dd>A <code>setf</code> place.

     <br><dt><var>new-pointer</var><dd>A foreign pointer.

     <br><dt><var>offset</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>incf-pointer</code> macro takes the foreign pointer from
<var>place</var> and creates a <var>new-pointer</var> incremented by
<var>offset</var> bytes and which is stored in <var>place</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*two-words*</span> <span class="paren2">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Common Lisp"</span></span>)</span></span>)</span>
  =&gt; *TWO-WORDS*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*one-word*</span> <span class="special">*two-words*</span></span>)</span>
  =&gt; *ONE-WORD*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">incf-pointer <span class="special">*one-word*</span> 7</span>)</span>
  =&gt; #.<span class="paren1">(<span class="lisp-bg">SB-SYS:INT-SAP #X00600457</span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp <span class="special">*one-word*</span></span>)</span>
  =&gt; "Lisp"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp <span class="special">*two-words*</span></span>)</span>
  =&gt; "Common Lisp"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#make_002dpointer">make-pointer</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a>

<!-- =================================================================== -->
<!-- MAKE-POINTER -->
<div class="node">
<a name="make-pointer"></a>
<a name="make_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mem_002daptr">mem-aptr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#incf_002dpointer">incf-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">make-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>make-pointer</b><var> address &rArr; ptr<a name="index-make_002dpointer-107"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>address</var><dd>An integer.

     <br><dt><var>ptr</var><dd>A foreign pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>make-pointer</code> will return a foreign pointer
pointing to <var>address</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">make-pointer 42</span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x0000002A&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
  =&gt; T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address **</span>)</span>
  =&gt; 42
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">inc-pointer <span class="special">***</span> -42</span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x00000000&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer-p *</span>)</span>
  =&gt; T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">typep ** 'foreign-pointer</span>)</span>
  =&gt; T
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#pointer_002daddress">pointer-address</a> <br>
<a href="#pointer_002deq">pointer-eq</a> <br>
<a href="#mem_002dref">mem-ref</a>

<!-- =================================================================== -->
<!-- MEM-APTR -->
<div class="node">
<a name="mem-aptr"></a>
<a name="mem_002daptr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mem_002daref">mem-aref</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#make_002dpointer">make-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">mem-aptr</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Accessor: <b>mem-aptr</b><var> ptr type &amp;optional </var>(<var>index 0</var>)<var><a name="index-mem_002daptr-108"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A foreign pointer.

     <br><dt><var>type</var><dd>A foreign type.

     <br><dt><var>index</var><dd>An integer.

     <br><dt><var>new-value</var><dd>A Lisp value compatible with <var>type</var>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>mem-aptr</code> function finds the pointer to an element of the array.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">mem-aptr ptr type n</span>)</span>
   
  <span class="comment">;; is identical to:
  </span> 
  <span class="paren1">(<span class="lisp-bg">inc-pointer ptr <span class="paren2">(<span class="lisp-bg">* n <span class="paren3">(<span class="lisp-bg">foreign-type-size type</span>)</span></span>)</span></span>)</span>
</pre>
   <h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"Hello, foreign world!"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">mem-aptr str <span class="keyword">:char</span> 6</span>)</span></span>)</span>
  =&gt; #.<span class="paren1">(<span class="lisp-bg">SB-SYS:INT-SAP #X0063D4B6</span>)</span>
</pre>
<!-- =================================================================== -->
<!-- MEM-AREF -->
<div class="node">
<a name="mem-aref"></a>
<a name="mem_002daref"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mem_002dref">mem-ref</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mem_002daptr">mem-aptr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">mem-aref</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Accessor: <b>mem-aref</b><var> ptr type &amp;optional </var>(<var>index 0</var>)<var><a name="index-mem_002daref-109"></a></var><br>
     </div>

   <p>(setf (<strong>mem-aref</strong> <em>ptr type &amp;optional (index 0)) new-value</em>)

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A foreign pointer.

     <br><dt><var>type</var><dd>A foreign type.

     <br><dt><var>index</var><dd>An integer.

     <br><dt><var>new-value</var><dd>A Lisp value compatible with <var>type</var>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>mem-aref</code> function is similar to <code>mem-ref</code> but will
automatically calculate the offset from an <var>index</var>.

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">mem-aref ptr type n</span>)</span>
   
  <span class="comment">;; is identical to:
  </span> 
  <span class="paren1">(<span class="lisp-bg">mem-ref ptr type <span class="paren2">(<span class="lisp-bg">* n <span class="paren3">(<span class="lisp-bg">foreign-type-size type</span>)</span></span>)</span></span>)</span>
</pre>
   <h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">str <span class="string">"Hello, foreign world!"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">mem-aref str <span class="keyword">:char</span> 6</span>)</span></span>)</span>
  =&gt; 32
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">code-char *</span>)</span>
  =&gt; #\Space
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10
                do <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> <span class="paren4">(<span class="lisp-bg">random 100</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10 collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">22 7 22 52 69 1 46 93 90 65</span>)</span>
</pre>
<h4 class="subheading">Compatibility Note</h4>

<p>For compatibility with older versions of CFFI, <a href="#mem_002daref">mem-aref</a> will
produce a pointer for the deprecated bare structure specification, but
it is consistent with other types for the current specification form
<code>(:struct </code><var>structure-name</var><code>)</code> and provides a Lisp object
translated from the structure (by default a plist).  In order to obtain
the pointer, you should use the new function <a href="#mem_002daptr">mem-aptr</a>.

<h4 class="subheading">See Also</h4>

<p><a href="#mem_002dref">mem-ref</a> <br>
<a href="#mem_002daptr">mem-aptr</a>

<!-- =================================================================== -->
<!-- MEM-REF -->
<div class="node">
<a name="mem-ref"></a>
<a name="mem_002dref"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#null_002dpointer">null-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mem_002daref">mem-aref</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">mem-ref</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Accessor: <b>mem-ref</b><var> ptr type &amp;optional offset &rArr; object<a name="index-mem_002dref-110"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A pointer.

     <br><dt><var>type</var><dd>A foreign type.

     <br><dt><var>offset</var><dd>An integer (in byte units).

     <br><dt><var>object</var><dd>The value <var>ptr</var> points to. 
</dl>

<h4 class="subheading">Description</h4>

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">ptr <span class="string">"Saluton"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref ptr <span class="keyword">:char</span> 3</span>)</span> <span class="paren3">(<span class="lisp-bg">char-code <span class="character">#\a</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 8
                collect <span class="paren3">(<span class="lisp-bg">code-char <span class="paren4">(<span class="lisp-bg">mem-ref ptr <span class="keyword">:char</span> i</span>)</span></span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="character">#\S</span> <span class="character">#\a</span> <span class="character">#\l</span> <span class="character">#\a</span> <span class="character">#\t</span> <span class="character">#\o</span> <span class="character">#\n</span> <span class="character">#\Null</span></span>)</span>
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">setq</span></i> ptr-to-int <span class="paren2">(<span class="lisp-bg">foreign-alloc <span class="keyword">:int</span></span>)</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #x1047D0&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span>
  =&gt; 1054619
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf <span class="paren2">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span> 1984</span>)</span>
  =&gt; 1984
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref ptr-to-int <span class="keyword">:int</span></span>)</span>
  =&gt; 1984
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#mem_002daref">mem-aref</a>

<!-- =================================================================== -->
<!-- NULL-POINTER -->
<div class="node">
<a name="null-pointer"></a>
<a name="null_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#null_002dpointer_002dp">null-pointer-p</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mem_002dref">mem-ref</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">null-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>null-pointer</b><var> &rArr; pointer<a name="index-null_002dpointer-111"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>pointer</var><dd>A <code>NULL</code> pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>null-pointer</code> returns a null pointer.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer</span>)</span>
  =&gt; #&lt;A Null Mac Pointer&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
  =&gt; T
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#make_002dpointer">make-pointer</a>

<!-- =================================================================== -->
<!-- NULL-POINTER-P -->
<div class="node">
<a name="null-pointer-p"></a>
<a name="null_002dpointer_002dp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#pointerp">pointerp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#null_002dpointer">null-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">null-pointer-p</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>null-pointer-p</b><var> ptr &rArr; boolean<a name="index-null_002dpointer_002dp-112"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A foreign pointer that may be a null pointer.

     <br><dt><var>boolean</var><dd><code>T</code> or <code>NIL</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>null-pointer-p</code> returns true if <var>ptr</var> is a null
pointer and false otherwise.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">null-pointer-p <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
  =&gt; T
</pre>
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defun</span></i> contains-str-p <span class="paren2">(<span class="lisp-bg">big little</span>)</span>
    <span class="paren2">(<span class="lisp-bg">not <span class="paren3">(<span class="lisp-bg">null-pointer-p
          <span class="paren4">(<span class="lisp-bg">foreign-funcall <span class="string">"strstr"</span> <span class="keyword">:string</span> big <span class="keyword">:string</span> little <span class="keyword">:pointer</span></span>)</span></span>)</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">contains-str-p <span class="string">"Popcorns"</span> <span class="string">"corn"</span></span>)</span>
  =&gt; T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">contains-str-p <span class="string">"Popcorns"</span> <span class="string">"salt"</span></span>)</span>
  =&gt; NIL
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#null_002dpointer">null-pointer</a> <br>
<a href="#pointerp">pointerp</a>

<!-- =================================================================== -->
<!-- POINTERP -->
<div class="node">
<a name="pointerp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#pointer_002daddress">pointer-address</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#null_002dpointer_002dp">null-pointer-p</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">pointerp</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>pointerp</b><var> ptr &rArr; boolean<a name="index-pointerp-113"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>An object that may be a foreign pointer.

     <br><dt><var>boolean</var><dd><code>T</code> or <code>NIL</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>pointerp</code> returns true if <var>ptr</var> is a foreign
pointer and false otherwise.

<h4 class="subheading">Implementation-specific Notes</h4>

<p>In Allegro CL, foreign pointers are integers thus in this
implementation <code>pointerp</code> will return true for any ordinary integer.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-alloc 32</span>)</span>
  =&gt; #&lt;A Mac Pointer #x102D20&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp *</span>)</span>
  =&gt; T
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointerp <span class="string">"this is not a pointer"</span></span>)</span>
  =&gt; NIL
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#make_002dpointer">make-pointer</a>
<a href="#null_002dpointer_002dp">null-pointer-p</a>

<!-- =================================================================== -->
<!-- POINTER-ADDRESS -->
<div class="node">
<a name="pointer-address"></a>
<a name="pointer_002daddress"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#pointer_002deq">pointer-eq</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pointerp">pointerp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">pointer-address</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>pointer-address</b><var> ptr &rArr; address<a name="index-pointer_002daddress-114"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A foreign pointer.

     <br><dt><var>address</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>pointer-address</code> will return the <var>address</var> of
a foreign pointer <var>ptr</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
  =&gt; 0
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-address <span class="paren2">(<span class="lisp-bg">make-pointer 123</span>)</span></span>)</span>
  =&gt; 123
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#make_002dpointer">make-pointer</a> <br>
<a href="#inc_002dpointer">inc-pointer</a> <br>
<a href="#null_002dpointer">null-pointer</a> <br>
<a href="#null_002dpointer_002dp">null-pointer-p</a> <br>
<a href="#pointerp">pointerp</a> <br>
<a href="#pointer_002deq">pointer-eq</a> <br>
<a href="#mem_002dref">mem-ref</a>

<!-- =================================================================== -->
<!-- POINTER-EQ -->
<div class="node">
<a name="pointer-eq"></a>
<a name="pointer_002deq"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#with_002dforeign_002dobject">with-foreign-object</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pointer_002daddress">pointer-address</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">pointer-eq</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>pointer-eq</b><var> ptr1 ptr2 &rArr; boolean<a name="index-pointer_002deq-115"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr1</var><dt><var>ptr2</var><dd>A foreign pointer.

     <br><dt><var>boolean</var><dd><code>T</code> or <code>NIL</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>pointer-eq</code> returns true if <var>ptr1</var> and
<var>ptr2</var> point to the same memory address and false otherwise.

<h4 class="subheading">Implementation-specific Notes</h4>

<p>The representation of foreign pointers varies across the various Lisp
implementations as does the behaviour of the built-in Common Lisp
equality predicates. Comparing two pointers that point to the same
address with <code>EQ</code> Lisps will return true on some Lisps, others require
more general predicates like <code>EQL</code> or <code>EQUALP</code> and finally
some will return false using any of these predicates. Therefore, for
portability, you should use <code>POINTER-EQ</code>.

<h4 class="subheading">Examples</h4>

<p>This is an example using <acronym>SBCL</acronym>, see the
implementation-specific notes above.

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">eql <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span> <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
  =&gt; NIL
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">pointer-eq <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span> <span class="paren2">(<span class="lisp-bg">null-pointer</span>)</span></span>)</span>
  =&gt; T
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#inc_002dpointer">inc-pointer</a>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-OBJECT -->
<div class="node">
<a name="with-foreign-object"></a>
<a name="with_002dforeign_002dobject"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#with_002dforeign_002dpointer">with-foreign-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#pointer_002deq">pointer-eq</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">with-foreign-object, with-foreign-objects</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>with-foreign-object</b> (<var>var type &amp;optional count</var>)<var> &amp;body body<a name="index-with_002dforeign_002dobject-116"></a></var><br>
     </div>

   <p><a name="with_002dforeign_002dobjects"></a>

<div class="defun">
&mdash; Macro: <b>with-foreign-objects</b> (<var>bindings</var>)<var> &amp;body body<a name="index-with_002dforeign_002dobjects-117"></a></var><br>
        </div>

   <p>bindings ::= {(var type &amp;optional count)}*

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>var</var><dd>A symbol.

     <br><dt><var>type</var><dd>A foreign type, evaluated.

     <br><dt><var>count</var><dd>An integer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The macros <code>with-foreign-object</code> and <code>with-foreign-objects</code>
bind <var>var</var> to a pointer to <var>count</var> newly allocated objects
of type <var>type</var> during <var>body</var>. The buffer has dynamic extent
and may be stack allocated if supported by the host Lisp.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="paren2">(<span class="lisp-bg">dotimes <span class="paren3">(<span class="lisp-bg">i 10</span>)</span>
            <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> <span class="paren4">(<span class="lisp-bg">random 100</span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i below 10
                collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">22 7 22 52 69 1 46 93 90 65</span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dalloc">foreign-alloc</a>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-POINTER -->
<div class="node">
<a name="with-foreign-pointer"></a>
<a name="with_002dforeign_002dpointer"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#with_002dforeign_002dobject">with-foreign-object</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Pointers">Pointers</a>

</div>

<h3 class="heading">with-foreign-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>with-foreign-pointer</b> (<var>var size &amp;optional size-var</var>)<var> &amp;body body<a name="index-with_002dforeign_002dpointer-118"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>var</var><dt><var>size-var</var><dd>A symbol.

     <br><dt><var>size</var><dd>An integer.

     <br><dt><var>body</var><dd>A list of forms to be executed. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>with-foreign-pointer</code> macro, binds <var>var</var> to <var>size</var>
bytes of foreign memory during <var>body</var>. The pointer in <var>var</var>
is invalid beyond the dynamic extend of <var>body</var> and may be
stack-allocated if supported by the implementation.

   <p>If <var>size-var</var> is supplied, it will be bound to <var>size</var> during
<var>body</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer</span></i> <span class="paren2">(<span class="lisp-bg">string 4 size</span>)</span>
          <span class="paren2">(<span class="lisp-bg">setf <span class="paren3">(<span class="lisp-bg">mem-ref string <span class="keyword">:char</span> <span class="paren4">(<span class="lisp-bg">1- size</span>)</span></span>)</span> 0</span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Popcorns"</span> string size</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below size
                collect <span class="paren3">(<span class="lisp-bg">code-char <span class="paren4">(<span class="lisp-bg">mem-ref string <span class="keyword">:char</span> i</span>)</span></span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="character">#\P</span> <span class="character">#\o</span> <span class="character">#\p</span> <span class="character">#\Null</span></span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dalloc">foreign-alloc</a> <br>
<a href="#foreign_002dfree">foreign-free</a>

<!-- =================================================================== -->
<!-- CHAPTER: Strings -->
<div class="node">
<a name="Strings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Variables">Variables</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Pointers">Pointers</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Strings</h2>

<p>As with many languages, Lisp and C have special support for logical
arrays of characters, going so far as to give them a special name,
&ldquo;strings&rdquo;.  In that spirit, <acronym>CFFI</acronym> provides special support for
translating between Lisp and C strings.

   <p>The <code>:string</code> type and the symbols related below also serve as an
example of what you can do portably with <acronym>CFFI</acronym>; were it not
included, you could write an equally functional <samp><span class="file">strings.lisp</span></samp>
without referring to any implementation-specific symbols.

</li></ul>
<p>Dictionary

<ul class="menu">
<li><a accesskey="1" href="#g_t_002adefault_002dforeign_002dencoding_002a">*default-foreign-encoding*</a>
<li><a accesskey="2" href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>
<li><a accesskey="3" href="#foreign_002dstring_002dfree">foreign-string-free</a>
<li><a accesskey="4" href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a>
<li><a accesskey="5" href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a>
<li><a accesskey="6" href="#with_002dforeign_002dstring">with-foreign-string</a>
<li><a accesskey="7" href="#with_002dforeign_002dstrings">with-foreign-strings</a>
<li><a accesskey="8" href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>
</ul>

<!-- =================================================================== -->
<!-- *DEFAULT-FOREIGN-ENCODING* -->
<div class="node">
<a name="*default-foreign-encoding*"></a>
<a name="g_t_002adefault_002dforeign_002dencoding_002a"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Strings">Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">*default-foreign-encoding*</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Special Variable: <b>*default-foreign-encoding*</b><var><a name="index-g_t_002adefault_002dforeign_002dencoding_002a-119"></a></var><br>
     </div>

<h4 class="subheading">Value type</h4>

<p>A keyword.

<h4 class="subheading">Initial value</h4>

<p><code>:utf-8</code>

<h4 class="subheading">Description</h4>

<p>This special variable holds the default foreign encoding.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; *default-foreign-encoding*
  :utf-8
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strdup"</span> <span class="paren2">(<span class="lisp-bg"><span class="keyword">:string</span> <span class="keyword">:encoding</span> <span class="keyword">:utf-16</span></span>)</span> <span class="string">"foo"</span> <span class="keyword">:string</span></span>)</span>
  "f"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="special">*default-foreign-encoding*</span> <span class="keyword">:utf-16</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strdup"</span> <span class="paren3">(<span class="lisp-bg"><span class="keyword">:string</span> <span class="keyword">:encoding</span> <span class="keyword">:utf-16</span></span>)</span> <span class="string">"foo"</span> <span class="keyword">:string</span></span>)</span></span>)</span>
  "foo"
</pre>
<h4 class="subheading">See also</h4>

<p><a href="#Other-Types">Other Types</a> (<code>:string</code> type) <br>
<a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <br>
<a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>

<!-- =================================================================== -->
<!-- FOREIGN-STRING-ALLOC -->
<div class="node">
<a name="foreign-string-alloc"></a>
<a name="foreign_002dstring_002dalloc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dstring_002dfree">foreign-string-free</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_002adefault_002dforeign_002dencoding_002a">*default-foreign-encoding*</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">foreign-string-alloc</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-string-alloc</b><var> string &amp;key encoding null-terminated-p start end &rArr; pointer<a name="index-foreign_002dstring_002dalloc-120"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>string</var><dd>A Lisp string.

     <br><dt><var>encoding</var><dd>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.

     <br><dt><var>null-terminated-p</var><dd>Boolean, defaults to true.

     <br><dt><var>start</var><em>, </em><var>end</var><dd>Bounding index designators of <var>string</var>. 0 and <code>nil</code>, by
default.

     <br><dt><var>pointer</var><dd>A pointer to the newly allocated foreign string. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-string-alloc</code> function allocates foreign memory
holding a copy of <var>string</var> converted using the specified
<var>encoding</var>. <var>Start</var> specifies an offset into <var>string</var> and
<var>end</var> marks the position following the last element of the foreign
string.

   <p>This string must be freed with <code>foreign-string-free</code>.

   <p>If <var>null-terminated-p</var> is false, the string will not be
null-terminated.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defparameter</span></i> <span class="special">*str*</span> <span class="paren2">(<span class="lisp-bg">foreign-string-alloc <span class="string">"Hello, foreign world!"</span></span>)</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #x00400560&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:pointer</span> <span class="special">*str*</span> <span class="keyword">:int</span></span>)</span>
  =&gt; 21
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dstring_002dfree">foreign-string-free</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a>
<!-- @seealso{:string} -->

<!-- =================================================================== -->
<!-- FOREIGN-STRING-FREE -->
<div class="node">
<a name="foreign-string-free"></a>
<a name="foreign_002dstring_002dfree"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">foreign-string-free</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-string-free</b><var> pointer<a name="index-foreign_002dstring_002dfree-121"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>pointer</var><dd>A pointer to a string allocated by <code>foreign-string-alloc</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-string-free</code> function frees a foreign string
allocated by <code>foreign-string-alloc</code>.

<h4 class="subheading">Examples</h4>

<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>

<!-- =================================================================== -->
<!-- FOREIGN-STRING-TO-LISP -->
<div class="node">
<a name="foreign-string-to-lisp"></a>
<a name="foreign_002dstring_002dto_002dlisp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dstring_002dfree">foreign-string-free</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">foreign-string-to-lisp</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>foreign-string-to-lisp</b><var> ptr &amp;key offset count max-chars encoding &rArr; string<a name="index-foreign_002dstring_002dto_002dlisp-122"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>ptr</var><dd>A pointer.

     <br><dt><var>offset</var><dd>An integer greater than or equal to 0. Defauls to 0.

     <br><dt><var>count</var><dd>Either <code>nil</code> (the default), or an integer greater than or equal to 0.

     <br><dt><var>max-chars</var><dd>An integer greater than or equal to 0. 
<code>(1- array-total-size-limit)</code>, by default.

     <br><dt><var>encoding</var><dd>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>.

     <br><dt><var>string</var><dd>A Lisp string. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-string-to-lisp</code> function converts at most
<var>count</var> octets from <var>ptr</var> into a Lisp string, using the
defined <var>encoding</var>.

   <p>If <var>count</var> is <code>nil</code> (the default), characters are copied
until <var>max-chars</var> is reached or a <code>NULL</code> character is found.

   <p>If <var>ptr</var> is a null pointer, returns <code>nil</code>.

   <p>Note that the <code>:string</code> type will automatically convert between
Lisp strings and foreign strings.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"getenv"</span> <span class="keyword">:string</span> <span class="string">"HOME"</span> <span class="keyword">:pointer</span></span>)</span>
  =&gt; #&lt;FOREIGN-ADDRESS #xBFFFFFD5&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-string-to-lisp *</span>)</span>
  =&gt; "/Users/luis"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a> <br>
<a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a>
<!-- @seealso{:string} -->

<!-- =================================================================== -->
<!-- LISP-STRING-TO-FOREIGN -->
<div class="node">
<a name="lisp-string-to-foreign"></a>
<a name="lisp_002dstring_002dto_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#with_002dforeign_002dstring">with-foreign-string</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">lisp-string-to-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>lisp-string-to-foreign</b><var> string buffer bufsize &amp;key start end offset encoding &rArr; buffer<a name="index-lisp_002dstring_002dto_002dforeign-123"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>string</var><dd>A Lisp string.

     <br><dt><var>buffer</var><dd>A foreign pointer.

     <br><dt><var>bufsize</var><dd>An integer.

     <br><dt><var>start</var><em>, </em><var>end</var><dd>Bounding index designators of <var>string</var>. 0 and <code>nil</code>, by
default.

     <br><dt><var>offset</var><dd>An integer greater than or equal to 0. Defauls to 0.

     <br><dt><var>encoding</var><dd>Foreign encoding. Defaults to <code>*default-foreign-encoding*</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>lisp-string-to-foreign</code> function copies at most
<var>bufsize</var>-1 octets from a Lisp <var>string</var> using the specified
<var>encoding</var> into <var>buffer</var>+<var>offset</var>. The foreign string will
be null-terminated.

   <p><var>Start</var> specifies an offset into <var>string</var> and
<var>end</var> marks the position following the last element of the foreign
string.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">str 255</span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Hello, foreign world!"</span> str 6</span>)</span></span>)</span>
  =&gt; "Hello"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-STRING -->
<div class="node">
<a name="with-foreign-string"></a>
<a name="with_002dforeign_002dstring"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">with-foreign-string, with-foreign-strings</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>with-foreign-string</b> (<var>var-or-vars string &amp;rest args</var>)<var> &amp;body body<a name="index-with_002dforeign_002dstring-124"></a></var><br>
     </div>

   <p><a name="with_002dforeign_002dstrings"></a>

<div class="defun">
&mdash; Macro: <b>with-foreign-strings</b> (<var>bindings</var>)<var> &amp;body body<a name="index-with_002dforeign_002dstrings-125"></a></var><br>
        </div>

   <p>var-or-vars ::= var | (var &amp;optional octet-size-var)
bindings ::= {(var-or-vars string &amp;rest args)}*

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>var</var><em>, </em><var>byte-size-var</var><dd>A symbol.

     <br><dt><var>string</var><dd>A Lisp string.

     <br><dt><var>body</var><dd>A list of forms to be executed. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>with-foreign-string</code> macro will bind <var>var</var> to a newly
allocated foreign string containing <var>string</var>. <var>Args</var> is passed
to the underlying <code>foreign-string-alloc</code> call.

   <p>If <var>octet-size-var</var> is provided, it will be bound the length of
foreign string in octets including the null terminator.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren2">(<span class="lisp-bg">foo <span class="string">"12345"</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:pointer</span> foo <span class="keyword">:int</span></span>)</span></span>)</span>
  =&gt; 5
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">array <span class="paren4">(<span class="lisp-bg">coerce #<span class="paren5">(<span class="lisp-bg">84 117 114 97 110 103 97</span>)</span>
                             '<span class="paren5">(<span class="lisp-bg">array <span class="paren6">(<span class="lisp-bg">unsigned-byte 8</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">with-foreign-string</span></i> <span class="paren3">(<span class="lisp-bg">foreign-string array</span>)</span>
            <span class="paren3">(<span class="lisp-bg">foreign-string-to-lisp foreign-string</span>)</span></span>)</span></span>)</span>
  =&gt; "Turanga"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a>

<!-- =================================================================== -->
<!-- WITH-FOREIGN-POINTER-AS-STRING -->
<div class="node">
<a name="with-foreign-pointer-as-string"></a>
<a name="with_002dforeign_002dpointer_002das_002dstring"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#with_002dforeign_002dstring">with-foreign-string</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="heading">with-foreign-pointer-as-string</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>with-foreign-pointer-as-string</b> (<var>var size &amp;optional size-var &amp;rest args</var>)<var> &amp;body body &rArr; string<a name="index-with_002dforeign_002dpointer_002das_002dstring-126"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>var</var><dd>A symbol.

     <br><dt><var>string</var><dd>A Lisp string.

     <br><dt><var>body</var><dd>List of forms to be executed. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>with-foreign-pointer-as-string</code> macro is similar to
<code>with-foreign-pointer</code> except that <var>var</var> is used as the
returned value of an implicit <code>progn</code> around <var>body</var>, after
being converted to a Lisp string using the provided <var>args</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">str 6 str-size <span class="keyword">:encoding</span> <span class="keyword">:ascii</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">lisp-string-to-foreign <span class="string">"Hello, foreign world!"</span> str str-size</span>)</span></span>)</span>
  =&gt; "Hello"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a> <br>
<a href="#with_002dforeign_002dstring">with-foreign-string</a>

<!-- =================================================================== -->
<!-- CHAPTER: Variables -->
<div class="node">
<a name="Variables"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Functions">Functions</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Strings">Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Variables</h2>

</li></ul>
<p>Dictionary

<ul class="menu">
<li><a accesskey="1" href="#defcvar">defcvar</a>
<li><a accesskey="2" href="#get_002dvar_002dpointer">get-var-pointer</a>
</ul>

<!-- =================================================================== -->
<!-- DEFCVAR -->
<div class="node">
<a name="defcvar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#get_002dvar_002dpointer">get-var-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>

</div>

<h3 class="heading">defcvar</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcvar</b><var> name-and-options type &amp;optional documentation &rArr; lisp-name<a name="index-defcvar-127"></a></var><br>
     </div>

   <p><var>name-and-options</var> ::= name | (name &amp;key read-only (library :default)) <br>
<var>name</var> ::= lisp-name [foreign-name] | foreign-name [lisp-name]

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-name</var><dd>A string denoting a foreign function.

     <br><dt><var>lisp-name</var><dd>A symbol naming the Lisp function to be created.

     <br><dt><var>type</var><dd>A foreign type.

     <br><dt><var>read-only</var><dd>A boolean.

     <br><dt><var>documentation</var><dd>A Lisp string; not evaluated. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defcvar</code> macro defines a symbol macro <var>lisp-name</var> that looks
up <var>foreign-name</var> and dereferences it acording to <var>type</var>.  It
can also be <code>setf</code>ed, unless <var>read-only</var> is true, in which
case an error will be signaled.

   <p>When one of <var>lisp-name</var> or <var>foreign-name</var> is omitted, the
other is automatically derived using the following rules:

     <ul>
<li>Foreign names are converted to Lisp names by uppercasing, replacing
underscores with hyphens, and wrapping around asterisks. 
<li>Lisp names are converted to foreign names by lowercasing, replacing
hyphens with underscores, and removing asterisks, if any. 
</ul>

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="string">"errno"</span> <span class="keyword">:int</span></span>)</span>
  =&gt; *ERRNO*
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strerror"</span> <span class="keyword">:int</span> <span class="special">*errno*</span> <span class="keyword">:string</span></span>)</span>
  =&gt; "Inappropriate ioctl for device"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf <span class="special">*errno*</span> 1</span>)</span>
  =&gt; 1
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strerror"</span> <span class="keyword">:int</span> <span class="special">*errno*</span> <span class="keyword">:string</span></span>)</span>
  =&gt; "Operation not permitted"
</pre>
   <p>Trying to modify a read-only foreign variable:

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"errno"</span> +error-number+ <span class="keyword">:read-only</span> t</span>)</span> <span class="keyword">:int</span></span>)</span>
  =&gt; +ERROR-NUMBER+
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">setf +error-number+ 12</span>)</span>
  <span class="comment">;; error--&gt; Trying to modify read-only foreign var: +ERROR-NUMBER+.
  </span>
</pre>
   <p><em>Note that accessing </em><code>errno</code><em> this way won't work with every
implementation of the C standard library.</em>

<h4 class="subheading">See Also</h4>

<p><a href="#get_002dvar_002dpointer">get-var-pointer</a>

<!-- =================================================================== -->
<!-- GET-VAR-POINTER -->
<div class="node">
<a name="get-var-pointer"></a>
<a name="get_002dvar_002dpointer"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcvar">defcvar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Variables">Variables</a>

</div>

<h3 class="heading">get-var-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>get-var-pointer</b><var> symbol &rArr; pointer<a name="index-get_002dvar_002dpointer-128"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>symbol</var><dd>A symbol denoting a foreign variable defined with <code>defcvar</code>.

     <br><dt><var>pointer</var><dd>A foreign pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The function <code>get-var-pointer</code> will return a <var>pointer</var> to the
foreign global variable <var>symbol</var> previously defined with
<code>defcvar</code>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcvar</span></i> <span class="string">"errno"</span> <span class="keyword">:int</span> <span class="keyword">:read-only</span> t</span>)</span>
  =&gt; *ERRNO*
  CFFI&gt; *errno*
  =&gt; 25
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">get-var-pointer '<span class="special">*errno*</span></span>)</span>
  =&gt; #&lt;A Mac Pointer #xA0008130&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">mem-ref * <span class="keyword">:int</span></span>)</span>
  =&gt; 25
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcvar">defcvar</a>

<!-- =================================================================== -->
<!-- CHAPTER: Functions -->
<div class="node">
<a name="Functions"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Libraries">Libraries</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Variables">Variables</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Functions</h2>

<!-- * Defining Foreign Functions:: -->
<!-- * Calling Foreign Functions:: -->
</li></ul>
<p>Dictionary

<ul class="menu">
<li><a accesskey="1" href="#defcfun">defcfun</a>
<li><a accesskey="2" href="#foreign_002dfuncall">foreign-funcall</a>
<li><a accesskey="3" href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>
<li><a accesskey="4" href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>
<li><a accesskey="5" href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a>
<li><a accesskey="6" href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>
<li><a accesskey="7" href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>
</ul>

<!-- @node Calling Foreign Functions -->
<!-- @section Calling Foreign Functions -->
<!-- @node Defining Foreign Functions -->
<!-- @section Defining Foreign Functions -->
<!-- =================================================================== -->
<!-- DEFCFUN -->
<div class="node">
<a name="defcfun"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dfuncall">foreign-funcall</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Functions">Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">defcfun</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcfun</b><var> name-and-options return-type &amp;body </var>[<var>docstring</var>]<var> arguments </var>[<var>&amp;rest</var>]<var> &rArr; lisp-name<a name="index-defcfun-129"></a></var><br>
     </div>

   <p><var>name-and-options</var> ::= name | (name &amp;key library convention) <br>
<var>name</var> ::= <var>lisp-name</var> [<var>foreign-name</var>] | <var>foreign-name</var> [<var>lisp-name</var>] <br>
<var>arguments</var> ::= { (arg-name arg-type) }* <br>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-name</var><dd>A string denoting a foreign function.

     <br><dt><var>lisp-name</var><dd>A symbol naming the Lisp function to be created.

     <br><dt><var>arg-name</var><dd>A symbol.

     <br><dt><var>return-type</var><dt><var>arg-type</var><dd>A foreign type.

     <br><dt><var>convention</var><dd>One of <code>:cdecl</code> (default) or <code>:stdcall</code>.

     <br><dt><var>library</var><dd>A symbol designating a foreign library.

     <br><dt><var>docstring</var><dd>A documentation string. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defcfun</code> macro provides a declarative interface for defining
Lisp functions that call foreign functions.

   <p>When one of <var>lisp-name</var> or <var>foreign-name</var> is omitted, the
other is automatically derived using the following rules:

     <ul>
<li>Foreign names are converted to Lisp names by uppercasing and replacing
underscores with hyphens. 
<li>Lisp names are converted to foreign names by lowercasing and replacing
hyphens with underscores. 
</ul>

   <p>If you place the symbol <code>&amp;rest</code> in the end of the argument list
after the fixed arguments, <code>defcfun</code> will treat the foreign
function as a <strong>variadic function</strong>. The variadic arguments
should be passed in a way similar to what <code>foreign-funcall</code> would
expect. Unlike <code>foreign-funcall</code> though, <code>defcfun</code> will take
care of doing argument promotion. Note that in this case
<code>defcfun</code> will generate a Lisp <em>macro</em> instead of a
function and will only work for Lisps that support
<code>foreign-funcall.</code>

   <p>If a foreign structure is to be passed or returned by value (that is,
the type is of the form <code>(:struct ...)</code>), then the cffi-libffi system
must be loaded, which in turn depends on
<a href="http://sourceware.org/libffi/">libffi</a>, including the header files. 
Failure to load that system will result in an error. 
Variadic functions cannot at present accept or return structures by
value.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"strlen"</span> <span class="keyword">:int</span>
    <span class="string">"Calculate the length of a string."</span>
    <span class="paren2">(<span class="lisp-bg">n <span class="keyword">:string</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">strlen <span class="string">"123"</span></span>)</span>
  =&gt; 3
</pre>
<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="paren2">(<span class="lisp-bg"><span class="string">"abs"</span> c-abs</span>)</span> <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg">n <span class="keyword">:int</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">c-abs -42</span>)</span>
  =&gt; 42
</pre>
   <p>Function without arguments:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"rand"</span> <span class="keyword">:int</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">rand</span>)</span>
  =&gt; 1804289383
</pre>
   <p>Variadic function example:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"sprintf"</span> <span class="keyword">:int</span>
    <span class="paren2">(<span class="lisp-bg">str <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">control <span class="keyword">:string</span></span>)</span>
    &amp;rest</span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-pointer-as-string</span></i> <span class="paren2">(<span class="lisp-bg">s 100</span>)</span>
          <span class="paren2">(<span class="lisp-bg">sprintf s <span class="string">"%c %d %.2f %s"</span> <span class="keyword">:char</span> 90 <span class="keyword">:short</span> 42 <span class="keyword">:float</span> pi
                   <span class="keyword">:string</span> <span class="string">"super-locrian"</span></span>)</span></span>)</span>
  =&gt; "A 42 3.14 super-locrian"
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#foreign_002dfuncall">foreign-funcall</a> <br>
<a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL -->
<div class="node">
<a name="foreign-funcall"></a>
<a name="foreign_002dfuncall"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcfun">defcfun</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">foreign-funcall</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>foreign-funcall</b><var> name-and-options &amp;rest arguments &rArr; return-value<a name="index-foreign_002dfuncall-130"></a></var><br>
     </div>

   <p>arguments ::= { arg-type arg }* [return-type]
name-and-options ::= name | ( name &amp;key library convention)

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>A Lisp string.

     <br><dt><var>arg-type</var><dd>A foreign type.

     <br><dt><var>arg</var><dd>An argument of type <var>arg-type</var>.

     <br><dt><var>return-type</var><dd>A foreign type, <code>:void</code> by default.

     <br><dt><var>return-value</var><dd>A lisp object.

     <br><dt><var>library</var><dd>A lisp symbol; not evaluated.

     <br><dt><var>convention</var><dd>One of <code>:cdecl</code> (default) or <code>:stdcall</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-funcall</code> macro is the main primitive for calling
foreign functions.

   <p>If a foreign structure is to be passed or returned by value (that is,
the type is of the form <code>(:struct ...)</code>), then the cffi-libffi system
must be loaded, which in turn depends on
<a href="http://sourceware.org/libffi/">libffi</a>, including the header files. 
Failure to load that system will result in an error. 
Variadic functions cannot at present accept or return structures by
value.

   <p><em>Note: The return value of foreign-funcall on functions with a
:void return type is still undefined.</em>

<h4 class="subheading">Implementation-specific Notes</h4>

     <ul>
<li>Corman Lisp does not support <code>foreign-funcall</code>. On
implementations that <strong>don't</strong> support <code>foreign-funcall</code>
<code>cffi-sys::no-foreign-funcall</code> will be present in
<code>*features*</code>. Note: in these Lisps you can still use the
<code>defcfun</code> interface. 
</ul>

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"strlen"</span> <span class="keyword">:string</span> <span class="string">"foo"</span> <span class="keyword">:int</span></span>)</span>
  =&gt; 3
</pre>
   <p>Given the C code:

<pre class="example">  void print_number(int n)
  {
      printf("N: %d\n", n);
  }
</pre>
   <pre class="lisp">  CFFI&gt; (foreign-funcall "print_number" :int 123456)
  -| N: 123456
  =&gt; NIL
</pre>
   <p class="noindent">Or, equivalently:

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall <span class="string">"print_number"</span> <span class="keyword">:int</span> 123456 <span class="keyword">:void</span></span>)</span>
  -| N: 123456
  =&gt; NIL
</pre>
   <pre class="lisp">  CFFI&gt; (foreign-funcall "printf" :string (format nil "%s: %d.~%")
                         :string "So long and thanks for all the fish"
                         :int 42 :int)
  -| So long and thanks for all the fish: 42.
  =&gt; 41
</pre>
   <h4 class="subheading">See Also</h4>

<p><a href="#defcfun">defcfun</a> <br>
<a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>

<!-- =================================================================== -->
<!-- FOREIGN-FUNCALL-POINTER -->
<div class="node">
<a name="foreign-funcall-pointer"></a>
<a name="foreign_002dfuncall_002dpointer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dfuncall">foreign-funcall</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">foreign-funcall-pointer</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>foreign-funcall-pointer</b><var> pointer options &amp;rest arguments &rArr; return-value<a name="index-foreign_002dfuncall_002dpointer-131"></a></var><br>
     </div>

   <p>arguments ::= { arg-type arg }* [return-type]
options ::= ( &amp;key convention )

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>pointer</var><dd>A foreign pointer.

     <br><dt><var>arg-type</var><dd>A foreign type.

     <br><dt><var>arg</var><dd>An argument of type <var>arg-type</var>.

     <br><dt><var>return-type</var><dd>A foreign type, <code>:void</code> by default.

     <br><dt><var>return-value</var><dd>A lisp object.

     <br><dt><var>convention</var><dd>One of <code>:cdecl</code> (default) or <code>:stdcall</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>foreign-funcall</code> macro is the main primitive for calling
foreign functions.

   <p><em>Note: The return value of foreign-funcall on functions with a
:void return type is still undefined.</em>

<h4 class="subheading">Implementation-specific Notes</h4>

     <ul>
<li>Corman Lisp does not support <code>foreign-funcall</code>. On
implementations that <strong>don't</strong> support <code>foreign-funcall</code>
<code>cffi-sys::no-foreign-funcall</code> will be present in
<code>*features*</code>. Note: in these Lisps you can still use the
<code>defcfun</code> interface. 
</ul>

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">foreign-funcall-pointer <span class="paren2">(<span class="lisp-bg">foreign-symbol-pointer <span class="string">"abs"</span></span>)</span> <span class="paren2">(<span class="lisp-bg"></span>)</span>
                                 <span class="keyword">:int</span> -42 <span class="keyword">:int</span></span>)</span>
  =&gt; 42
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcfun">defcfun</a> <br>
<a href="#foreign_002dfuncall">foreign-funcall</a>

<!-- =================================================================== -->
<!-- TRANSLATE-CAMELCASE-NAME -->
<div class="node">
<a name="translate-camelcase-name"></a>
<a name="translate_002dcamelcase_002dname"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">translate-camelcase-name</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>translate-camelcase-name</b><var> name &amp;key upper-initial-p special-words &rArr; return-value<a name="index-translate_002dcamelcase_002dname-132"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>Either a symbol or a string.

     <br><dt><var>upper-initial-p</var><dd>A generalized boolean.

     <br><dt><var>special words</var><dd>A list of strings.

     <br><dt><var>return-value</var><dd>If <var>name</var> is a symbol, this is a string, and vice versa. 
</dl>

<h4 class="subheading">Description</h4>

<p><code>translate-camelcase-name</code> is a helper function for
specializations of <code>translate-name-from-foreign</code> and
<code>translate-name-to-foreign</code>. It handles the common case of
converting between foreign camelCase names and lisp
names. <var>upper-initial-p</var> indicates whether the first letter of the
foreign name should be uppercase. <var>special-words</var> is a list of
strings that should be treated atomically in translation. This list is
case-sensitive.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function</span>)</span>
  =&gt; "someXmlFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function <span class="keyword">:upper-initial-p</span> t</span>)</span>
  =&gt; "SomeXmlFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name some-xml-function <span class="keyword">:special-words</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"XML"</span></span>)</span></span>)</span>
  =&gt; "someXMLFunction"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"someXMLFunction"</span></span>)</span>
  =&gt; SOME-X-M-L-FUNCTION
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"someXMLFunction"</span> <span class="keyword">:special-words</span> '<span class="paren2">(<span class="lisp-bg"><span class="string">"XML"</span></span>)</span></span>)</span>
  =&gt; SOME-XML-FUNCTION
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>

<!-- =================================================================== -->
<!-- TRANSLATE-NAME-FROM-FOREIGN -->
<div class="node">
<a name="translate-name-from-foreign"></a>
<a name="translate_002dname_002dfrom_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">translate-name-from-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>translate-name-from-foreign</b><var> foreign-name package &amp;optional varp &rArr; symbol<a name="index-translate_002dname_002dfrom_002dforeign-133"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>foreign-name</var><dd>A string denoting a foreign function.

     <br><dt><var>package</var><dd>A Lisp package

     <br><dt><var>varp</var><dd>A generalized boolean.

     <br><dt><var>symbol</var><dd>The Lisp symbol to be used a function name. 
</dl>

<h4 class="subheading">Description</h4>

<p><code>translate-name-from-foreign</code> is used by <a href="#defcfun">defcfun</a> to handle
the conversion of foreign names to lisp names. By default, it
translates using <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. However,
you can create specialized methods on this function to make
translating more closely match the foreign library's naming
conventions.

   <p>Specialize <var>package</var> on some package. This allows other packages
to load libraries with different naming conventions.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"someXmlFunction"</span> ...</span>)</span>
  =&gt; SOMEXMLFUNCTION
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-name-from-foreign <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">spec string</span>)</span>
                                                <span class="paren3">(<span class="lisp-bg">package <span class="paren4">(<span class="lisp-bg">eql <span class="special">*package*</span></span>)</span></span>)</span>
                                                &amp;optional varp</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">name <span class="paren5">(<span class="lisp-bg">translate-camelcase-name spec</span>)</span></span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">if</span></i> varp <span class="paren4">(<span class="lisp-bg">intern <span class="paren5">(<span class="lisp-bg">format nil <span class="string">"*~a*"</span> name</span>)</span></span>)</span> name</span>)</span></span>)</span></span>)</span>
  =&gt; #&lt;STANDARD-METHOD TRANSLATE-NAME-FROM-FOREIGN <span class="paren1">(<span class="lisp-bg">STRING <span class="paren2">(<span class="lisp-bg">EQL #&lt;Package <span class="string">"SOME-PACKAGE"</span>&gt;</span>)</span></span>)</span>&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"someXmlFunction"</span> ...</span>)</span>
  =&gt; SOME-XML-FUNCTION
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcfun">defcfun</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>

<!-- =================================================================== -->
<!-- TRANSLATE-NAME-TO-FOREIGN -->
<div class="node">
<a name="translate-name-to-foreign"></a>
<a name="translate_002dname_002dto_002dforeign"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">translate-name-to-foreign</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>translate-name-to-foreign</b><var> lisp-name package &amp;optional varp &rArr; string<a name="index-translate_002dname_002dto_002dforeign-134"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>lisp-name</var><dd>A symbol naming the Lisp function to be created.

     <br><dt><var>package</var><dd>A Lisp package

     <br><dt><var>varp</var><dd>A generalized boolean.

     <br><dt><var>string</var><dd>The string representing the foreign function name. 
</dl>

<h4 class="subheading">Description</h4>

<p><code>translate-name-to-foreign</code> is used by <a href="#defcfun">defcfun</a> to handle
the conversion of lisp names to foreign names. By default, it
translates using <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>. However,
you can create specialized methods on this function to make
translating more closely match the foreign library's naming
conventions.

   <p>Specialize <var>package</var> on some package. This allows other packages
to load libraries with different naming conventions.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> some-xml-function ...</span>)</span>
  =&gt; "some_xml_function"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defmethod</span></i> translate-name-to-foreign <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">spec symbol</span>)</span>
                                              <span class="paren3">(<span class="lisp-bg">package <span class="paren4">(<span class="lisp-bg">eql <span class="special">*package*</span></span>)</span></span>)</span>
                                              &amp;optional varp</span>)</span>
          <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">name <span class="paren5">(<span class="lisp-bg">translate-camelcase-name spec</span>)</span></span>)</span></span>)</span>
            <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">if</span></i> varp <span class="paren4">(<span class="lisp-bg">subseq name 1 <span class="paren5">(<span class="lisp-bg">1- <span class="paren6">(<span class="lisp-bg">length name</span>)</span></span>)</span></span>)</span> name</span>)</span></span>)</span></span>)</span>
  =&gt; #&lt;STANDARD-METHOD TRANSLATE-NAME-TO-FOREIGN <span class="paren1">(<span class="lisp-bg">STRING <span class="paren2">(<span class="lisp-bg">EQL #&lt;Package <span class="string">"SOME-PACKAGE"</span>&gt;</span>)</span></span>)</span>&gt;
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> some-xml-function ...</span>)</span>
  =&gt; "someXmlFunction"
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#defcfun">defcfun</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a> <br>
<a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a>

<!-- =================================================================== -->
<!-- TRANSLATE-UNDERSCORE-SEPARATED-NAME -->
<div class="node">
<a name="translate-underscore-separated-name"></a>
<a name="translate_002dunderscore_002dseparated_002dname"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Functions">Functions</a>

</div>

<h3 class="heading">translate-underscore-separated-name</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>translate-underscore-separated-name</b><var> name &rArr; return-value<a name="index-translate_002dunderscore_002dseparated_002dname-135"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>Either a symbol or a string.

     <br><dt><var>return-value</var><dd>If <var>name</var> is a symbol, this is a string, and vice versa. 
</dl>

<h4 class="subheading">Description</h4>

<p><code>translate-underscore-separated-name</code> is a helper function for
specializations of <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> and
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a>. It handles the common case of
converting between foreign underscore_separated names and lisp names.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-underscore-separated-name some-xml-function</span>)</span>
  =&gt; "some_xml_function"
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">translate-camelcase-name <span class="string">"some_xml_function"</span></span>)</span>
  =&gt; SOME-XML-FUNCTION
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a> <br>
<a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a> <br>
<a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a>

<!-- =================================================================== -->
<!-- CHAPTER: Libraries -->
<div class="node">
<a name="Libraries"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Callbacks">Callbacks</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Functions">Functions</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 Libraries</h2>

<ul class="menu">
<li><a accesskey="1" href="#Defining-a-library">Defining a library</a>
<li><a accesskey="2" href="#Library-definition-style">Library definition style</a>

</li></ul>
<p>Dictionary

</p>
<ul class="menu">
<li><a accesskey="3" href="#close_002dforeign_002dlibrary">close-foreign-library</a>:        Close a foreign library. 
<li><a accesskey="4" href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a>:   Search path for Darwin frameworks. 
<li><a accesskey="5" href="#define_002dforeign_002dlibrary">define-foreign-library</a>:       Explain how to load a foreign library. 
<li><a accesskey="6" href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>:   Search path for shared libraries. 
<li><a accesskey="7" href="#load_002dforeign_002dlibrary">load-foreign-library</a>:         Load a foreign library. 
<li><a accesskey="8" href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a>:   Signalled on failure of its namesake. 
<li><a accesskey="9" href="#use_002dforeign_002dlibrary">use-foreign-library</a>:          Load a foreign library when needed. 
</ul>

<div class="node">
<a name="Defining-a-library"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Library-definition-style">Library definition style</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Libraries">Libraries</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="section">11.1 Defining a library</h3>

<p>Almost all foreign code you might want to access exists in some kind
of shared library.  The meaning of <dfn>shared library</dfn> varies among
platforms, but for our purposes, we will consider it to include
<samp><span class="file">.so</span></samp> files on <span class="sc">unix</span>, frameworks on Darwin (and derivatives
like Mac <acronym>OS X</acronym>), and <samp><span class="file">.dll</span></samp> files on Windows.

   <p>Bringing one of these libraries into the Lisp image is normally a
two-step process.

     <ol type=1 start=1>
<li>Describe to <acronym>CFFI</acronym> how to load the library at some future point,
depending on platform and other factors, with a
<code>define-foreign-library</code> top-level form.

     <li>Load the library so defined with either a top-level
<code>use-foreign-library</code> form or by calling the function
<code>load-foreign-library</code>.
        </ol>

   <p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>, for a working
example of the above two steps.

<div class="node">
<a name="Library-definition-style"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#close_002dforeign_002dlibrary">close-foreign-library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Defining-a-library">Defining a library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="section">11.2 Library definition style</h3>

<p>Looking at the <code>libcurl</code> library definition presented earlier,
you may ask why we did not simply do this:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">define-foreign-library</span></i> libcurl
    <span class="paren2">(<span class="lisp-bg">t <span class="paren3">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"libcurl"</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">Indeed, this would work just as well on the computer on which I tested
the tutorial.  There are a couple of good reasons to provide the
<samp><span class="file">.so</span></samp>'s current version number, however.  Namely, the versionless
<samp><span class="file">.so</span></samp> is not packaged on most <span class="sc">unix</span> systems along with the
actual, fully-versioned library; instead, it is included in the
&ldquo;development&rdquo; package along with C headers and static <samp><span class="file">.a</span></samp>
libraries.

   <p>The reason <acronym>CFFI</acronym> does not try to account for this lies in the
meaning of the version numbers.  A full treatment of shared library
versions is beyond this manual's scope; see <a href="http://www.gnu.org/software/libtool/manual.html#Versioning">Library interface versions</a>, for helpful
information for the unfamiliar.  For our purposes, consider that a
mismatch between the library version with which you tested and the
installed library version may cause undefined
behavior.<a rel="footnote" href="#fn-12" name="fnd-12"><sup>12</sup></a>

   <blockquote>
<strong>Implementor's note:</strong> <em>Maybe some notes should go here about OS X, which I know
little about.  &ndash;stephen</em>
</blockquote>

<!-- =================================================================== -->
<!-- CLOSE-FOREIGN-LIBRARY -->
<div class="node">
<a name="close-foreign-library"></a>
<a name="close_002dforeign_002dlibrary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Library-definition-style">Library definition style</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">close-foreign-library</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>close-foreign-library</b><var> library &rArr; success<a name="index-close_002dforeign_002dlibrary-136"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>library</var><dd>A symbol or an instance of <code>foreign-library</code>.

     <br><dt><var>success</var><dd>A Lisp boolean. 
</dl>

<h4 class="subheading">Description</h4>

<p>Closes <var>library</var> which can be a symbol designating a library
define through <code>define-foreign-library</code> or an instance of
<code>foreign-library</code> as returned by <code>load-foreign-library</code>.

<!-- @subheading Examples -->
<!-- @xref{Tutorial-Loading,, Loading foreign libraries}. -->
<h4 class="subheading">See Also</h4>

<p><a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <br>
<a href="#load_002dforeign_002dlibrary">load-foreign-library</a> <br>
<a href="#use_002dforeign_002dlibrary">use-foreign-library</a>

<!-- =================================================================== -->
<!-- *DARWIN-FRAMEWORK-DIRECTORIES* -->
<div class="node">
<a name="*darwin-framework-directories*"></a>
<a name="g_t_002adarwin_002dframework_002ddirectories_002a"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#define_002dforeign_002dlibrary">define-foreign-library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#close_002dforeign_002dlibrary">close-foreign-library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">*darwin-framework-directories*</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Special Variable: <b>*darwin-framework-directories*</b><var><a name="index-g_t_002adarwin_002dframework_002ddirectories_002a-137"></a></var><br>
     </div>

<h4 class="subheading">Value type</h4>

<p>A list, in which each element is a string, a pathname, or a simple
Lisp expression.

<h4 class="subheading">Initial value</h4>

<p>A list containing the following, in order: an expression corresponding
to Darwin path <samp><span class="file">~/Library/Frameworks/</span></samp>,
<code>#P"/Library/Frameworks/"</code>, and
<code>#P"/System/Library/Frameworks/"</code>.

<h4 class="subheading">Description</h4>

<p>The meaning of &ldquo;simple Lisp expression&rdquo; is explained in
<a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>.  In contrast to that variable,
this is not a fallback search path; the default value described above
is intended to be a reasonably complete search path on Darwin systems.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">lib <span class="paren4">(<span class="lisp-bg">load-foreign-library '<span class="paren5">(<span class="lisp-bg"><span class="keyword">:framework</span> <span class="string">"OpenGL"</span></span>)</span></span>)</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">foreign-library-pathname lib</span>)</span></span>)</span>
  =&gt; #P"/System/Library/Frameworks/OpenGL.framework/OpenGL"
</pre>
<h4 class="subheading">See also</h4>

<p><a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a>

<!-- =================================================================== -->
<!-- DEFINE-FOREIGN-LIBRARY -->
<div class="node">
<a name="define-foreign-library"></a>
<a name="define_002dforeign_002dlibrary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">define-foreign-library</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>define-foreign-library</b><var> name-and-options { load-clause }* &rArr; name<a name="index-define_002dforeign_002dlibrary-138"></a></var><br>
     </div>

   <p>name-and-options ::= name | (name &amp;key convention search-path)
load-clause ::= (feature library &amp;key convention search-path)

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>A symbol.

     <br><dt><var>feature</var><dd>A feature expression.

     <br><dt><var>library</var><dd>A library designator.

     <br><dt><var>convention</var><dd>One of <code>:cdecl</code> (default) or <code>:stdcall</code>

     <br><dt><var>search-path</var><dd>A path or list of paths where the library will be searched if not found in
system-global directories. Paths specified in a load clause take priority over
paths specified as library option, with *foreign-library-directories* having
lowest priority. 
</dl>

<h4 class="subheading">Description</h4>

<p>Creates a new library designator called <var>name</var>.  The
<var>load-clause</var>s describe how to load that designator when passed to
<code>load-foreign-library</code> or <code>use-foreign-library</code>.

   <p>When trying to load the library <var>name</var>, the relevant function
searches the <var>load-clause</var>s in order for the first one where
<var>feature</var> evaluates to true.  That happens for any of the
following situations:

     <ol type=1 start=1>
<li>If <var>feature</var> is a symbol present in <code>common-lisp:*features*</code>.

     <li>If <var>feature</var> is a list, depending on <code>(first </code><var>feature</var><code>)</code>,
a keyword:

          <dl>
<dt><code>:and</code><dd>All of the feature expressions in <code>(rest </code><var>feature</var><code>)</code> are
true.

          <br><dt><code>:or</code><dd>At least one of the feature expressions in <code>(rest </code><var>feature</var><code>)</code>
is true.

          <br><dt><code>:not</code><dd>The feature expression <code>(second </code><var>feature</var><code>)</code> is not true. 
</dl>

     <li>Finally, if <var>feature</var> is <code>t</code>, this <var>load-clause</var> is
picked unconditionally.
        </ol>

   <p>Upon finding the first true <var>feature</var>, the library loader then
loads the <var>library</var>.  The meaning of &ldquo;library designator&rdquo; is
described in <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>.

   <p>Functions associated to a library defined by
<code>define-foreign-library</code> (e.g. through <code>defcfun</code>'s
<code>:library</code> option, will inherit the library's options.  The
precedence is as follows:

     <ol type=1 start=1>
<li><code>defcfun</code>/<code>foreign-funcall</code> specific options;

     <li><var>load-clause</var> options;

     <li>global library options (the <var>name-and-options</var> argument)
        </ol>

<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.

<h4 class="subheading">See Also</h4>

<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <br>
<a href="#load_002dforeign_002dlibrary">load-foreign-library</a>

<!-- =================================================================== -->
<!-- *FOREIGN-LIBRARY-DIRECTORIES* -->
<div class="node">
<a name="*foreign-library-directories*"></a>
<a name="g_t_002aforeign_002dlibrary_002ddirectories_002a"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#load_002dforeign_002dlibrary">load-foreign-library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#define_002dforeign_002dlibrary">define-foreign-library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">*foreign-library-directories*</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Special Variable: <b>*foreign-library-directories*</b><var><a name="index-g_t_002aforeign_002dlibrary_002ddirectories_002a-139"></a></var><br>
     </div>

<h4 class="subheading">Value type</h4>

<p>A list, in which each element is a string, a pathname, or a simple
Lisp expression.

<h4 class="subheading">Initial value</h4>

<p>The empty list.

<h4 class="subheading">Description</h4>

<p>You should not have to use this variable.

   <p>Most, if not all, Lisps supported by <acronym>CFFI</acronym> have a reasonable default
search algorithm for foreign libraries.  For example, Lisps for
<span class="sc">unix</span> usually call
<a href="http://www.opengroup.org/onlinepubs/009695399/functions/dlopen.html"><code>dlopen(3)</code></a>, which in turn looks in the system library
directories.  Only if that fails does <acronym>CFFI</acronym> look for the named
library file in these directories, and load it from there if found.

   <p>Thus, this is intended to be a <acronym>CFFI</acronym>-only fallback to the library
search configuration provided by your operating system.  For example,
if you distribute a foreign library with your Lisp package, you can
add the library's containing directory to this list and portably
expect <acronym>CFFI</acronym> to find it.

   <p>A <dfn>simple Lisp expression</dfn> is intended to provide functionality
commonly used in search paths such as
<acronym>ASDF</acronym>'s<a rel="footnote" href="#fn-13" name="fnd-13"><sup>13</sup></a>, and is defined recursively as
follows:<a rel="footnote" href="#fn-14" name="fnd-14"><sup>14</sup></a>

     <ol type=1 start=1>
<li>A list, whose &lsquo;<samp><span class="samp">first</span></samp>&rsquo; is a function designator, and whose
&lsquo;<samp><span class="samp">rest</span></samp>&rsquo; is a list of simple Lisp expressions to be evaluated and
passed to the so-designated function.  The result is the result of the
function call.

     <li>A symbol, whose result is its symbol value.

     <li>Anything else evaluates to itself.
        </ol>

<h4 class="subheading">Examples</h4>

<pre class="example">  $ ls
  -| liblibli.so    libli.lisp
</pre>
<p class="noindent">In <samp><span class="file">libli.lisp</span></samp>:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">pushnew #P<span class="string">"/home/sirian/lisp/libli/"</span> <span class="special">*foreign-library-directories*</span>
           <span class="keyword">:test</span> #'equal</span>)</span>
   
  <span class="paren1">(<span class="lisp-bg">load-foreign-library '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"liblibli"</span></span>)</span></span>)</span>
</pre>
   <p class="noindent">The following example would achieve the same effect:

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">pushnew '<span class="paren2">(<span class="lisp-bg">merge-pathnames #p<span class="string">"lisp/libli/"</span> <span class="paren3">(<span class="lisp-bg">user-homedir-pathname</span>)</span></span>)</span>
            <span class="special">*foreign-library-directories*</span>
            <span class="keyword">:test</span> #'equal</span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg"><span class="paren2">(<span class="lisp-bg">MERGE-PATHNAMES #P<span class="string">"lisp/libli/"</span> <span class="paren3">(<span class="lisp-bg">USER-HOMEDIR-PATHNAME</span>)</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg">load-foreign-library '<span class="paren2">(<span class="lisp-bg"><span class="keyword">:default</span> <span class="string">"liblibli"</span></span>)</span></span>)</span>
</pre>
   <h4 class="subheading">See also</h4>

<p><a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a>

<!-- =================================================================== -->
<!-- LOAD-FOREIGN-LIBRARY -->
<div class="node">
<a name="load-foreign-library"></a>
<a name="load_002dforeign_002dlibrary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">load-foreign-library</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Function: <b>load-foreign-library</b><var> library-designator &rArr; library<a name="index-load_002dforeign_002dlibrary-140"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>library-designator</var><dd>A library designator.

     <br><dt><var>library-designator</var><dd>An instance of <code>foreign-library</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>Load the library indicated by <var>library-designator</var>. A <dfn>library
designator</dfn> is defined as follows:

     <ol type=1 start=1>
<li>If a symbol, is considered a name previously defined with
<code>define-foreign-library</code>.

     <li>If a string or pathname, passed as a namestring directly to the
implementation's foreign library loader.  If that fails, search the
directories in <code>*foreign-library-directories*</code> with
<code>cl:probe-file</code>; if found, the absolute path is passed to the
implementation's loader.

     <li>If a list, the meaning depends on <code>(first </code><var>library</var><code>)</code>:

          <dl>
<dt><code>:framework</code><dd>The second list element is taken to be a Darwin framework name, which
is then searched in <code>*darwin-framework-directories*</code>, and loaded
when found.

          <br><dt><code>:or</code><dd>Each remaining list element, itself a library designator, is loaded in
order, until one succeeds.

          <br><dt><code>:default</code><dd>The name is transformed according to the platform's naming convention
to shared libraries, and the resultant string is loaded as a library
designator.  For example, on <span class="sc">unix</span>, the name is suffixed with
<samp><span class="file">.so</span></samp>. 
</dl>
     </ol>

   <p>If the load fails, signal a <code>load-foreign-library-error</code>.

   <p><strong>Please note:</strong> For system libraries, you should not need to
specify the directory containing the library.  Each operating system
has its own idea of a default search path, and you should rely on it
when it is reasonable.

<h4 class="subheading">Implementation-specific Notes</h4>

<p>On ECL platforms where its dynamic FFI is not supported (ie. when
<code>:dffi</code> is not present in <code>*features*</code>),
<code>cffi:load-foreign-library</code> does not work and you must use ECL's
own <code>ffi:load-foreign-library</code> with a constant string argument.

<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.

<h4 class="subheading">See Also</h4>

<p><a href="#close_002dforeign_002dlibrary">close-foreign-library</a> <br>
<a href="#g_t_002adarwin_002dframework_002ddirectories_002a">*darwin-framework-directories*</a> <br>
<a href="#define_002dforeign_002dlibrary">define-foreign-library</a> <br>
<a href="#g_t_002aforeign_002dlibrary_002ddirectories_002a">*foreign-library-directories*</a> <br>
<a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a> <br>
<a href="#use_002dforeign_002dlibrary">use-foreign-library</a>

<!-- =================================================================== -->
<!-- LOAD-FOREIGN-LIBRARY-ERROR -->
<div class="node">
<a name="load-foreign-library-error"></a>
<a name="load_002dforeign_002dlibrary_002derror"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#use_002dforeign_002dlibrary">use-foreign-library</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#load_002dforeign_002dlibrary">load-foreign-library</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">load-foreign-library-error</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Condition Type: <b>load-foreign-library-error</b><var><a name="index-load_002dforeign_002dlibrary_002derror-141"></a></var><br>
     </div>

<h4 class="subheading">Class precedence list</h4>

<p><code>load-foreign-library-error</code>, <code>error</code>,
<code>serious-condition</code>, <code>condition</code>, <code>t</code>

<h4 class="subheading">Description</h4>

<p>Signalled when a foreign library load completely fails.  The exact
meaning of this varies depending on the real conditions at work, but
almost universally, the implementation's error message is useless. 
However, <acronym>CFFI</acronym> does provide the useful restarts <code>retry</code> and
<code>use-value</code>; invoke the <code>retry</code> restart to try loading the
foreign library again, or the <code>use-value</code> restart to try loading
a different foreign library designator.

<h4 class="subheading">See also</h4>

<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a>

<!-- =================================================================== -->
<!-- USE-FOREIGN-LIBRARY -->
<div class="node">
<a name="use-foreign-library"></a>
<a name="use_002dforeign_002dlibrary"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Libraries">Libraries</a>

</div>

<h3 class="heading">use-foreign-library</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>use-foreign-library</b><var> name<a name="index-use_002dforeign_002dlibrary-142"></a></var><br>
     </div>

<h4 class="subheading">Arguments and values</h4>

     <dl>
<dt><var>name</var><dd>A library designator; unevaluated. 
</dl>

<h4 class="subheading">Description</h4>

<p>See <a href="#load_002dforeign_002dlibrary">load-foreign-library</a>, for the meaning of &ldquo;library
designator&rdquo;.  This is intended to be the top-level form used
idiomatically after a <code>define-foreign-library</code> form to go ahead
and load the library. <!-- ; it also sets the ``current foreign library''. -->
Finally, on implementations where the regular evaluation rule is
insufficient for foreign library loading, it loads it at the required
time.<a rel="footnote" href="#fn-15" name="fnd-15"><sup>15</sup></a>

<!-- current foreign library is a concept created a few hours ago as of -->
<!-- this writing.  It is not actually used yet, but probably will be. -->
<h4 class="subheading">Examples</h4>

<p>See <a href="#Tutorial_002dLoading">Loading foreign libraries</a>.

<h4 class="subheading">See also</h4>

<p><a href="#load_002dforeign_002dlibrary">load-foreign-library</a>

<!-- =================================================================== -->
<!-- CHAPTER: Callbacks -->
<div class="node">
<a name="Callbacks"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#The-Groveller">The Groveller</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Libraries">Libraries</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">12 Callbacks</h2>

</li></ul>
<p>Dictionary

<ul class="menu">
<li><a accesskey="1" href="#callback">callback</a>
<li><a accesskey="2" href="#defcallback">defcallback</a>
<li><a accesskey="3" href="#get_002dcallback">get-callback</a>
</ul>

<!-- =================================================================== -->
<!-- CALLBACK -->
<div class="node">
<a name="callback"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#defcallback">defcallback</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Callbacks">Callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Callbacks">Callbacks</a>

</div>

<h3 class="heading">callback</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>callback</b><var> symbol &rArr; pointer<a name="index-callback-143"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>symbol</var><dd>A symbol denoting a callback.

     <br><dt><var>pointer</var><dt><var>new-value</var><dd>A pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>callback</code> macro is analogous to the standard CL special
operator <code>function</code> and will return a pointer to the callback
denoted by the symbol <var>name</var>.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> sum <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">+ a b</span>)</span></span>)</span>
  =&gt; SUM
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">callback sum</span>)</span>
  =&gt; #&lt;A Mac Pointer #x102350&gt;
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#get_002dcallback">get-callback</a> <br>
<a href="#defcallback">defcallback</a>

<!-- =================================================================== -->
<!-- DEFCALLBACK -->
<div class="node">
<a name="defcallback"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#get_002dcallback">get-callback</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#callback">callback</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Callbacks">Callbacks</a>

</div>

<h3 class="heading">defcallback</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Macro: <b>defcallback</b><var> name-and-options return-type arguments &amp;body body &rArr; name<a name="index-defcallback-144"></a></var><br>
     </div>

   <p>name-and-options ::= name | (name &amp;key convention)
arguments ::= ({ (arg-name arg-type) }*)

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>name</var><dd>A symbol naming the callback created.

     <br><dt><var>return-type</var><dd>The foreign type for the callback's return value.

     <br><dt><var>arg-name</var><dd>A symbol.

     <br><dt><var>arg-type</var><dd>A foreign type.

     <br><dt><var>convention</var><dd>One of <code>:cdecl</code> (default) or <code>:stdcall</code>. 
</dl>

<h4 class="subheading">Description</h4>

<p>The <code>defcallback</code> macro defines a Lisp function that can be called
from C. The arguments passed to this function will be converted to the
appropriate Lisp representation and its return value will be converted
to its C representation.

   <p>This Lisp function can be accessed by the <code>callback</code> macro or the
<code>get-callback</code> function.

   <p><strong>Portability note:</strong> <code>defcallback</code> will not work correctly
on some Lisps if it's not a top-level form.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcfun</span></i> <span class="string">"qsort"</span> <span class="keyword">:void</span>
    <span class="paren2">(<span class="lisp-bg">base <span class="keyword">:pointer</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">nmemb <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">size <span class="keyword">:int</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">fun-compar <span class="keyword">:pointer</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> &lt; <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:pointer</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:pointer</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">let</span></i> <span class="paren3">(<span class="lisp-bg"><span class="paren4">(<span class="lisp-bg">x <span class="paren5">(<span class="lisp-bg">mem-ref a <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren4">(<span class="lisp-bg">y <span class="paren5">(<span class="lisp-bg">mem-ref b <span class="keyword">:int</span></span>)</span></span>)</span></span>)</span>
      <span class="paren3">(<span class="lisp-bg"><i><span class="symbol">cond</span></i> <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">&gt; x y</span>)</span> 1</span>)</span>
            <span class="paren4">(<span class="lisp-bg"><span class="paren5">(<span class="lisp-bg">&lt; x y</span>)</span> -1</span>)</span>
            <span class="paren4">(<span class="lisp-bg">t 0</span>)</span></span>)</span></span>)</span></span>)</span>
   
  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">with-foreign-object</span></i> <span class="paren2">(<span class="lisp-bg">array <span class="keyword">:int</span> 10</span>)</span>
          <span class="comment">;; Initialize array.
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 and n in '<span class="paren3">(<span class="lisp-bg">7 2 10 4 3 5 1 6 9 8</span>)</span>
                do <span class="paren3">(<span class="lisp-bg">setf <span class="paren4">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span> n</span>)</span></span>)</span>
          <span class="comment">;; Sort it.
  </span>        <span class="paren2">(<span class="lisp-bg">qsort array 10 <span class="paren3">(<span class="lisp-bg">foreign-type-size <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">callback &lt;</span>)</span></span>)</span>
          <span class="comment">;; Return it as a list.
  </span>        <span class="paren2">(<span class="lisp-bg"><i><span class="symbol">loop</span></i> for i from 0 below 10
                collect <span class="paren3">(<span class="lisp-bg">mem-aref array <span class="keyword">:int</span> i</span>)</span></span>)</span></span>)</span>
  =&gt; <span class="paren1">(<span class="lisp-bg">1 2 3 4 5 6 7 8 9 10</span>)</span>
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#callback">callback</a> <br>
<a href="#get_002dcallback">get-callback</a>

<!-- =================================================================== -->
<!-- GET-CALLBACK -->
<div class="node">
<a name="get-callback"></a>
<a name="get_002dcallback"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#defcallback">defcallback</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Callbacks">Callbacks</a>

</div>

<h3 class="heading">get-callback</h3>

<h4 class="subheading">Syntax</h4>

<div class="defun">
&mdash; Accessor: <b>get-callback</b><var> symbol &rArr; pointer<a name="index-get_002dcallback-145"></a></var><br>
     </div>

<h4 class="subheading">Arguments and Values</h4>

     <dl>
<dt><var>symbol</var><dd>A symbol denoting a callback.

     <br><dt><var>pointer</var><dd>A pointer. 
</dl>

<h4 class="subheading">Description</h4>

<p>This is the functional version of the <code>callback</code> macro. It
returns a pointer to the callback named by <var>symbol</var> suitable, for
example, to pass as arguments to foreign functions.

<h4 class="subheading">Examples</h4>

<pre class="lisp">  CFFI&gt; <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defcallback</span></i> sum <span class="keyword">:int</span> <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg">a <span class="keyword">:int</span></span>)</span> <span class="paren3">(<span class="lisp-bg">b <span class="keyword">:int</span></span>)</span></span>)</span>
          <span class="paren2">(<span class="lisp-bg">+ a b</span>)</span></span>)</span>
  =&gt; SUM
  CFFI&gt; <span class="paren1">(<span class="lisp-bg">get-callback 'sum</span>)</span>
  =&gt; #&lt;A Mac Pointer #x102350&gt;
</pre>
<h4 class="subheading">See Also</h4>

<p><a href="#callback">callback</a> <br>
<a href="#defcallback">defcallback</a>

<!-- =================================================================== -->
<!-- CHAPTER: The Groveller -->
<div class="node">
<a name="The-Groveller"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Limitations">Limitations</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Callbacks">Callbacks</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">13 The Groveller</h2>

<p><acronym>CFFI</acronym>-Grovel is a tool which makes it easier to write <acronym>CFFI</acronym>
declarations for libraries that are implemented in C.  That is, it
grovels through the system headers, getting information about types
and structures, so you don't have to.  This is especially important
for libraries which are implemented in different ways by different
vendors, such as the <span class="sc">unix</span>/<span class="sc">posix</span> functions.  The <acronym>CFFI</acronym>
declarations are usually quite different from platform to platform,
but the information you give to <acronym>CFFI</acronym>-Grovel is the same.  Hence,
much less work is required!

   <p>If you use <acronym>ASDF</acronym>, <acronym>CFFI</acronym>-Grovel is integrated, so that it
will run automatically when your system is building.  This feature was
inspired by SB-Grovel, a similar <acronym>SBCL</acronym>-specific project. 
<acronym>CFFI</acronym>-Grovel can also be used without <acronym>ASDF</acronym>.

<h3 class="section">13.1 Building FFIs with CFFI-Grovel</h3>

<p><acronym>CFFI</acronym>-Grovel uses a specification file (*.lisp) describing the
features that need groveling.  The C compiler is used to retrieve this
data and write a Lisp file (*.cffi.lisp) which contains the necessary
<acronym>CFFI</acronym> definitions to access the variables, structures, constants, and
enums mentioned in the specification.

<!-- This is most similar to the SB-Grovel package, upon which it is -->
<!-- based.  Unlike SB-Grovel, we do not currently support defining -->
<!-- regular foreign functions in the specification file; those are best -->
<!-- defined in normal Lisp code. -->
   <p><acronym>CFFI</acronym>-Grovel provides an <acronym>ASDF</acronym> component for handling the
necessary calls to the C compiler and resulting file management.

<!-- See the included CFFI-Unix package for an example of how to -->
<!-- integrate a specification file with ASDF-built packages. -->
<ul class="menu">
<li><a accesskey="1" href="#Groveller-Syntax">Groveller Syntax</a>:             How grovel files should look like. 
<li><a accesskey="2" href="#Groveller-ASDF-Integration">Groveller ASDF Integration</a>:   ASDF components for grovel files. 
<li><a accesskey="3" href="#Groveller-Implementation-Notes">Groveller Implementation Notes</a>:  Implementation notes. 
</ul>

<div class="node">
<a name="Groveller-Syntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Groveller-ASDF-Integration">Groveller ASDF Integration</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Groveller">The Groveller</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Groveller">The Groveller</a>

</div>

<h3 class="section">13.2 Specification File Syntax</h3>

<p>The specification files are read by the normal Lisp reader, so they
have syntax very similar to normal Lisp code.  In particular,
semicolon-comments and reader-macros will work as expected.

   <p>There are several forms recognized by <acronym>CFFI</acronym>-Grovel:

<div class="defun">
&mdash; Grovel Form: <b>progn</b><var> &amp;rest forms<a name="index-progn-146"></a></var><br>
<blockquote>
        <p>Processes a list of forms. Useful for conditionalizing several
forms. For example:
</p></blockquote></div>

<pre class="lisp">  #+freebsd
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">progn</span></i>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-enable <span class="string">"EV_ENABLE"</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">constant <span class="paren3">(<span class="lisp-bg">ev-disable <span class="string">"EV_DISABLE"</span></span>)</span></span>)</span></span>)</span>
</pre>
   <div class="defun">
&mdash; Grovel Form: <b>include</b><var> &amp;rest files<a name="index-include-147"></a></var><br>
<blockquote>
        <p>Include the specified files (specified as strings) in the generated C
source code. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>in-package</b><var> symbol<a name="index-in_002dpackage-148"></a></var><br>
<blockquote>
        <p>Set the package to be used for the final Lisp output. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>ctype</b><var> lisp-name size-designator<a name="index-ctype-149"></a></var><br>
<blockquote>
        <p>Define a <acronym>CFFI</acronym> foreign type for the string in <var>size-designator</var>,
e.g. <code>(ctype :pid "pid_t")</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>constant</b> (<var>lisp-name &amp;rest c-names</var>)<var> &amp;key type documentation optional<a name="index-constant-150"></a></var><br>
<blockquote>
        <p>Search for the constant named by the first <var>c-name</var> string found
to be known to the C preprocessor and define it as <var>lisp-name</var>.

        <p>The <var>type</var> keyword argument specifies how to grovel the constant:
either <code>integer</code> (the default) or <code>double-float</code>. If
<var>optional</var> is true, no error will be raised if all the
<var>c-names</var> are unknown. If <var>lisp-name</var> is a keyword, the actual
constant will be a symbol of the same name interned in the current
package. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>define</b><var> name &amp;optional value<a name="index-define-151"></a></var><br>
<blockquote>
        <p>Defines an additional C preprocessor symbol, which is useful for
altering the behavior of included system headers. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cc-flags</b><var> &amp;rest flags<a name="index-cc_002dflags-152"></a></var><br>
<blockquote>
        <p>Adds <var>cc-flags</var> to the command line arguments used for the C compiler
invocation. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cstruct</b><var> lisp-name c-name slots<a name="index-cstruct-153"></a></var><br>
<blockquote>
        <p>Define a <acronym>CFFI</acronym> foreign struct with the slot data specfied.  Slots
are of the form <code>(lisp-name c-name &amp;key type count (signed t))</code>. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cunion</b><var> lisp-name c-name slots<a name="index-cunion-154"></a></var><br>
<blockquote>
        <p>Identical to <code>cstruct</code>, but defines a <acronym>CFFI</acronym> foreign union. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cstruct-and-class</b><var> c-name slots<a name="index-cstruct_002dand_002dclass-155"></a></var><br>
<blockquote>
        <p>Defines a <acronym>CFFI</acronym> foreign struct, as with <code>cstruct</code> and defines a
<acronym>CLOS</acronym> class to be used with it.  This is useful for mapping
foreign structures to application-layer code that shouldn't need to
worry about memory allocation issues. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cvar</b><var> namespec type &amp;key read-only<a name="index-cvar-156"></a></var><br>
<blockquote>
        <p>Defines a foreign variable of the specified type, even if that
variable is potentially a C preprocessor pseudo-variable.  e.g. 
<code>(cvar ("errno" errno) errno-values)</code>, assuming that errno-values
is an enum or equivalent to type <code>:int</code>.

        <p>The <var>namespec</var> is similar to the one used in <a href="#defcvar">defcvar</a>. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>cenum</b><var> name-and-opts &amp;rest elements<a name="index-cenum-157"></a></var><br>
<blockquote>
        <p>Defines a true C enum, with elements specified as <code>((lisp-name
&amp;rest c-names) &amp;key optional documentation)</code>. 
<var>name-and-opts</var> can be either a symbol as name, or a list
<code>(name &amp;key base-type define-constants)</code>. If <var>define-constants</var>
is non-null, a Lisp constant will be defined for each enum member. 
</p></blockquote></div>

<div class="defun">
&mdash; Grovel Form: <b>constantenum</b><var> name-and-opts &amp;rest elements<a name="index-constantenum-158"></a></var><br>
<blockquote>
        <p>Defines an enumeration of pre-processor constants, with elements
specified as <code>((lisp-name &amp;rest c-names) &amp;key optional
documentation)</code>. 
<var>name-and-opts</var> can be either a symbol as name, or a list
<code>(name &amp;key base-type define-constants)</code>. If <var>define-constants</var>
is non-null, a Lisp constant will be defined for each enum member.

        <p>This example defines <code>:af-inet</code> to represent the value held by
<code>AF_INET</code> or <code>PF_INET</code>, whichever the pre-processor finds
first.  Similarly for <code>:af-packet</code>, but no error will be
signalled if the platform supports neither <code>AF_PACKET</code> nor
<code>PF_PACKET</code>. 
</p></blockquote></div>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">constantenum address-family
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-inet</span> <span class="string">"AF_INET"</span> <span class="string">"PF_INET"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"IPv4 Protocol family"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-local</span> <span class="string">"AF_UNIX"</span> <span class="string">"AF_LOCAL"</span> <span class="string">"PF_UNIX"</span> <span class="string">"PF_LOCAL"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"File domain sockets"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-inet6</span> <span class="string">"AF_INET6"</span> <span class="string">"PF_INET6"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"IPv6 Protocol family"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:af-packet</span> <span class="string">"AF_PACKET"</span> <span class="string">"PF_PACKET"</span></span>)</span>
     <span class="keyword">:documentation</span> <span class="string">"Raw packet access"</span>
     <span class="keyword">:optional</span> t</span>)</span></span>)</span>
</pre>
   <div class="defun">
&mdash; Grovel Form: <b>bitfield</b><var> name-and-opts &amp;rest elements<a name="index-bitfield-159"></a></var><br>
<blockquote>
        <p>Defines a bitfield, with elements specified as <code>((lisp-name
c-name) &amp;key documentation)</code>.  <var>name-and-opts</var> can be either a
symbol as name, or a list <code>(name &amp;key base-type)</code>.  For example:
</p></blockquote></div>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg">bitfield flags-ctype
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-a</span> <span class="string">"FLAG_A"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_A"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-b</span> <span class="string">"FLAG_B"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_B"</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:flag-c</span> <span class="string">"FLAG_C"</span></span>)</span>
      <span class="keyword">:documentation</span> <span class="string">"DOCU_C"</span></span>)</span></span>)</span>
</pre>
   <!-- =================================================================== -->
<!-- SECTION: Groveller ASDF Integration -->
<div class="node">
<a name="Groveller-ASDF-Integration"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Groveller-Implementation-Notes">Groveller Implementation Notes</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Groveller-Syntax">Groveller Syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Groveller">The Groveller</a>

</div>

<h3 class="section">13.3 ASDF Integration</h3>

<p>An example software project might contain four files; an
<acronym>ASDF</acronym> file, a package definition file, an implementation
file, and a <acronym>CFFI</acronym>-Grovel specification file.

   <p>The <acronym>ASDF</acronym> file defines the system and its dependencies. 
Notice the use of <code>eval-when</code> to ensure <acronym>CFFI</acronym>-Grovel is present
and the use of <code>(cffi-grovel:grovel-file name &amp;key cc-flags)</code>
instead of <code>(:file name)</code>.

<pre class="lisp">  <span class="comment">;;; CFFI-Grovel is needed for processing grovel-file components
  </span><span class="paren1">(<span class="lisp-bg"><i><span class="symbol">cl:eval-when</span></i> <span class="paren2">(<span class="lisp-bg"><span class="keyword">:load-toplevel</span> <span class="keyword">:execute</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg">asdf:operate 'asdf:load-op 'cffi-grovel</span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">asdf:defsystem</span></i> example-software
    <span class="keyword">:depends-on</span> <span class="paren2">(<span class="lisp-bg">cffi</span>)</span>
    <span class="keyword">:serial</span> t
    <span class="keyword">:components</span>
    <span class="paren2">(<span class="lisp-bg"><span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"package"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg">cffi-grovel:grovel-file <span class="string">"example-grovelling"</span></span>)</span>
     <span class="paren3">(<span class="lisp-bg"><span class="keyword">:file</span> <span class="string">"example"</span></span>)</span></span>)</span></span>)</span>
</pre>
   <p>The &ldquo;package.lisp&rdquo; file would contain several <code>defpackage</code>
forms, to remove circular dependencies and make building the project
easier.  Note that you may or may not want to <code>:use</code> your
internal package.

   <blockquote>
<strong>Implementor's note:</strong> <em>Mention that it's a not a good idea to :USE when names may
clash with, say, CL symbols.</em>
</blockquote>

<pre class="lisp">  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">#:example-internal</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span></span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:nicknames</span> <span class="keyword">#:exampleint</span></span>)</span></span>)</span>
   
  <span class="paren1">(<span class="lisp-bg"><i><span class="symbol">defpackage</span></i> <span class="keyword">#:example-software</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:export</span> ...</span>)</span>
    <span class="paren2">(<span class="lisp-bg"><span class="keyword">:use</span> <span class="keyword">#:cl</span> <span class="keyword">#:cffi</span> <span class="keyword">#:exampleint</span></span>)</span></span>)</span>
</pre>
   <p>The internal package is created by Lisp code output from the C program
written by <acronym>CFFI</acronym>-Grovel; if your specification file is
exampleint.lisp, the exampleint.cffi.lisp file will contain the
<acronym>CFFI</acronym> definitions needed by the rest of your project. 
See <a href="#Groveller-Syntax">Groveller Syntax</a>.

<div class="node">
<a name="Groveller-Implementation-Notes"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Groveller-ASDF-Integration">Groveller ASDF Integration</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#The-Groveller">The Groveller</a>

</div>

<h3 class="section">13.4 Implementation Notes</h3>

<blockquote>
<strong>Implementor's note:</strong> <em>This info might not be up-to-date.</em>
</blockquote>

   <p>For <code>foo-internal.lisp</code>, the resulting <code>foo-internal.c</code>,
<code>foo-internal</code>, and <code>foo-internal.cffi.lisp</code> are all
platform-specific, either because of possible reader-macros in
foo-internal.lisp, or because of varying C environments on the host
system.  For this reason, it is not helpful to distribute any of those
files; end users building <acronym>CFFI</acronym>-Grovel based software will need
<code>cffi</code>-Grovel anyway.

   <p>If you build with multiple architectures in the same directory
(e.g. with NFS/AFS home directories), it is critical to remove these
generated files or the resulting constants will be very incorrect.

   <blockquote>
<strong>Implementor's note:</strong> <em>Maybe we should tag the generated names with something host
or OS-specific?</em>
</blockquote>

   <blockquote>
<strong>Implementor's note:</strong> <em>For now, after some experimentation with </em><span class="sc">clisp</span><em> having no
long-long, it seems appropriate to assert that the generated </em><code>.c</code><em>
files are architecture and operating-system dependent, but
lisp-implementation independent.  This way the same </em><code>.c</code><em> file
(and so the same </em><code>.grovel-tmp.lisp</code><em> file) will be shareable
between the implementations running on a given system.</em>
</blockquote>

<!-- TODO: document the new wrapper stuff. -->
<!-- =================================================================== -->
<!-- CHAPTER: Limitations -->
<div class="node">
<a name="Limitations"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Platform_002dspecific-features">Platform-specific features</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#The-Groveller">The Groveller</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">14 Limitations</h2>

<p>These are <acronym>CFFI</acronym>'s limitations across all platforms; for information
on the warts on particular Lisp implementations, see
<a href="#Implementation-Support">Implementation Support</a>.

     <ul>
<li>The tutorial includes a treatment of the primary, intractable
limitation of <acronym>CFFI</acronym>, or any <acronym>FFI</acronym>: that the abstractions
commonly used by C are insufficiently expressive. 
See <a href="#Tutorial_002dAbstraction">Breaking the abstraction</a>, for more
details.

     <li>C <code>struct</code>s cannot be passed by value. 
</ul>

<div class="node">
<a name="Platform-specific-features"></a>
<a name="Platform_002dspecific-features"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Glossary">Glossary</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Limitations">Limitations</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix A Platform-specific features</h2>

<p>Whenever a backend doesn't support one of <acronym>CFFI</acronym>'s features, a
specific symbol is pushed onto <code>common-lisp:*features*</code>.  The
meanings of these symbols follow.

     <dl>
<dt><var>cffi-sys::flat-namespace</var><dd>This Lisp has a flat namespace for foreign symbols meaning that you
won't be able to load two different libraries with homograph functions
and successfully differentiate them through the <code>:library</code>
option to <code>defcfun</code>, <code>defcvar</code>, etc<small class="dots">...</small>

     <br><dt><var>cffi-sys::no-foreign-funcall</var><dd>The macro <code>foreign-funcall</code> is <strong>not</strong> available.  On such
platforms, the only way to call a foreign function is through
<code>defcfun</code>.  See <a href="#foreign_002dfuncall">foreign-funcall</a>, and <a href="#defcfun">defcfun</a>.

     <br><dt><var>cffi-sys::no-long-long</var><dd>The C <code>long long</code> type is <strong>not</strong> available as a foreign
type.

     <p>However, on such platforms <acronym>CFFI</acronym> provides its own implementation of
the <code>long long</code> type for all of operations in chapters
<a href="#Foreign-Types">Foreign Types</a>, <a href="#Pointers">Pointers</a> and <a href="#Variables">Variables</a>. The
functionality described in <a href="#Functions">Functions</a> and <a href="#Callbacks">Callbacks</a> will
not be available.

     <p>32-bit Lispworks 5.0+ is an exception. In addition to the <acronym>CFFI</acronym>
implementation described above, Lispworks itself implements the
<code>long long</code> type for <a href="#Functions">Functions</a>. <a href="#Callbacks">Callbacks</a> are still
missing <code>long long</code> support, though.

     <br><dt><var>cffi-sys::no-stdcall</var><dd>This Lisp doesn't support the <code>stdcall</code> calling convention.  Note
that it only makes sense to support <code>stdcall</code> on (32-bit) x86
platforms.

   </dl>

<div class="node">
<a name="Glossary"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Comprehensive-Index">Comprehensive Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Platform_002dspecific-features">Platform-specific features</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="appendix">Appendix B Glossary</h2>

     <dl>
<dt><dfn>aggregate type</dfn><dd>A <acronym>CFFI</acronym> type for C data defined as an organization of data of simple
type; in structures and unions, which are themselves aggregate types,
they are represented by value.

     <br><dt><dfn>foreign value</dfn><dd>This has two meanings; in any context, only one makes sense.

     <p>When using type translators, the foreign value is the lower-level Lisp
value derived from the object passed to <code>translate-to-foreign</code>
(see <a href="#translate_002dto_002dforeign">translate-to-foreign</a>).  This value should be a Lisp number or
a pointer (satisfies <code>pointerp</code>), and it can be treated like any
general Lisp object; it only completes the transformation to a true
foreign value when passed through low-level code in the Lisp
implementation, such as the foreign function caller or indirect memory
addressing combined with a data move.

     <p>In other contexts, this refers to a value accessible by C, but which
may only be accessed through <acronym>CFFI</acronym> functions.  The closest you can
get to such a foreign value is through a pointer Lisp object, which
itself counts as a foreign value in only the previous sense.

     <br><dt><dfn>simple type</dfn><dd>A <acronym>CFFI</acronym> type that is ultimately represented as a builtin type;
<acronym>CFFI</acronym> only provides extra semantics for Lisp that are invisible to C
code or data. 
</dl>

<div class="node">
<a name="Comprehensive-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Glossary">Glossary</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-g_t_003aboolean-71"><code>:boolean</code></a>: <a href="#Other-Types">Other Types</a></li>
<li><a href="#index-g_t_003achar-40"><code>:char</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003adouble-65"><code>:double</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003afloat-64"><code>:float</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aint-44"><code>:int</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aint16-58"><code>:int16</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aint32-60"><code>:int32</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aint64-62"><code>:int64</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aint8-56"><code>:int8</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003allong-54"><code>:llong</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003along-46"><code>:long</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003along_002ddouble-66"><code>:long-double</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003along_002dlong-48"><code>:long-long</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003apointer-67"><code>:pointer</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003ashort-42"><code>:short</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003astring-69"><code>:string</code></a>: <a href="#Other-Types">Other Types</a></li>
<li><a href="#index-g_t_003astring_002bptr-70"><code>:string+ptr</code></a>: <a href="#Other-Types">Other Types</a></li>
<li><a href="#index-g_t_003auchar-50"><code>:uchar</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003auint-52"><code>:uint</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003auint16-59"><code>:uint16</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003auint32-61"><code>:uint32</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003auint64-63"><code>:uint64</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003auint8-57"><code>:uint8</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aullong-55"><code>:ullong</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aulong-53"><code>:ulong</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aunsigned_002dchar-41"><code>:unsigned-char</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aunsigned_002dint-45"><code>:unsigned-int</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aunsigned_002dlong-47"><code>:unsigned-long</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aunsigned_002dlong_002dlong-49"><code>:unsigned-long-long</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aunsigned_002dshort-43"><code>:unsigned-short</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003aushort-51"><code>:ushort</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003avoid-68"><code>:void</code></a>: <a href="#Built_002dIn-Types">Built-In Types</a></li>
<li><a href="#index-g_t_003awrapper-72"><code>:wrapper</code></a>: <a href="#Other-Types">Other Types</a></li>
<li><a href="#index-abstraction-breaking-26">abstraction breaking</a>: <a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></li>
<li><a href="#index-abstractions-in-C-11">abstractions in C</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-advantages-of-_0040acronym_007bFFI_007d-7">advantages of <acronym>FFI</acronym></a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-benefits-of-_0040acronym_007bFFI_007d-8">benefits of <acronym>FFI</acronym></a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-bitfield-159"><code>bitfield</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-breaking-the-abstraction-25">breaking the abstraction</a>: <a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></li>
<li><a href="#index-C-abstractions-10">C abstractions</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-callback-143"><code>callback</code></a>: <a href="#callback">callback</a></li>
<li><a href="#index-callback-definition-34">callback definition</a>: <a href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a></li>
<li><a href="#index-calling-foreign-functions-19">calling foreign functions</a>: <a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></li>
<li><a href="#index-cc_002dflags-152"><code>cc-flags</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-cenum-157"><code>cenum</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-close_002dforeign_002dlibrary-136"><code>close-foreign-library</code></a>: <a href="#close_002dforeign_002dlibrary">close-foreign-library</a></li>
<li><a href="#index-compiler-macros-for-type-translation-74">compiler macros for type translation</a>: <a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></li>
<li><a href="#index-constant-150"><code>constant</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-constantenum-158"><code>constantenum</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-convert_002dfrom_002dforeign-76"><code>convert-from-foreign</code></a>: <a href="#convert_002dfrom_002dforeign">convert-from-foreign</a></li>
<li><a href="#index-convert_002dto_002dforeign-77"><code>convert-to-foreign</code></a>: <a href="#convert_002dto_002dforeign">convert-to-foreign</a></li>
<li><a href="#index-cstruct-153"><code>cstruct</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-cstruct_002dand_002dclass-155"><code>cstruct-and-class</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-ctype-149"><code>ctype</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-cunion-154"><code>cunion</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-c_0040acronym_007bURL_007d-13">c<acronym>URL</acronym></a>: <a href="#Tutorial_002dGetting-a-URL">Tutorial-Getting a URL</a></li>
<li><a href="#index-cvar-156"><code>cvar</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-data-in-Lisp-and-C-37">data in Lisp and C</a>: <a href="#Tutorial_002dTypes">Tutorial-Types</a></li>
<li><a href="#index-defbitfield-78"><code>defbitfield</code></a>: <a href="#defbitfield">defbitfield</a></li>
<li><a href="#index-defcallback-144"><code>defcallback</code></a>: <a href="#defcallback">defcallback</a></li>
<li><a href="#index-defcenum-82"><code>defcenum</code></a>: <a href="#defcenum">defcenum</a></li>
<li><a href="#index-defcfun-129"><code>defcfun</code></a>: <a href="#defcfun">defcfun</a></li>
<li><a href="#index-defcstruct-79"><code>defcstruct</code></a>: <a href="#defcstruct">defcstruct</a></li>
<li><a href="#index-defctype-81"><code>defctype</code></a>: <a href="#defctype">defctype</a></li>
<li><a href="#index-defcunion-80"><code>defcunion</code></a>: <a href="#defcunion">defcunion</a></li>
<li><a href="#index-defcvar-127"><code>defcvar</code></a>: <a href="#defcvar">defcvar</a></li>
<li><a href="#index-define-151"><code>define</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-define_002dforeign_002dlibrary-138"><code>define-foreign-library</code></a>: <a href="#define_002dforeign_002dlibrary">define-foreign-library</a></li>
<li><a href="#index-define_002dforeign_002dtype-83"><code>define-foreign-type</code></a>: <a href="#define_002dforeign_002dtype">define-foreign-type</a></li>
<li><a href="#index-define_002dparse_002dmethod-84"><code>define-parse-method</code></a>: <a href="#define_002dparse_002dmethod">define-parse-method</a></li>
<li><a href="#index-defining-callbacks-35">defining callbacks</a>: <a href="#Tutorial_002dCallbacks">Tutorial-Callbacks</a></li>
<li><a href="#index-defining-type_002dtranslation-compiler-macros-75">defining type-translation compiler macros</a>: <a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></li>
<li><a href="#index-dynamic-extent-30">dynamic extent</a>: <a href="#Tutorial_002dMemory">Tutorial-Memory</a></li>
<li><a href="#index-enumeration_002c-C-24">enumeration, C</a>: <a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></li>
<li><a href="#index-g_t_0040sc_007bfile_007d_002a-and-streams-28"><span class="sc">file</span>* and streams</a>: <a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></li>
<li><a href="#index-foreign-arguments-23">foreign arguments</a>: <a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></li>
<li><a href="#index-foreign-functions-and-data-2">foreign functions and data</a>: <a href="#Tutorial">Tutorial</a></li>
<li><a href="#index-foreign-library-load-16">foreign library load</a>: <a href="#Tutorial_002dLoading">Tutorial-Loading</a></li>
<li><a href="#index-foreign-values-with-dynamic-extent-31">foreign values with dynamic extent</a>: <a href="#Tutorial_002dMemory">Tutorial-Memory</a></li>
<li><a href="#index-foreign_002dalloc-103"><code>foreign-alloc</code></a>: <a href="#foreign_002dalloc">foreign-alloc</a></li>
<li><a href="#index-foreign_002dbitfield_002dsymbols-85"><code>foreign-bitfield-symbols</code></a>: <a href="#foreign_002dbitfield_002dsymbols">foreign-bitfield-symbols</a></li>
<li><a href="#index-foreign_002dbitfield_002dvalue-86"><code>foreign-bitfield-value</code></a>: <a href="#foreign_002dbitfield_002dvalue">foreign-bitfield-value</a></li>
<li><a href="#index-foreign_002denum_002dkeyword-87"><code>foreign-enum-keyword</code></a>: <a href="#foreign_002denum_002dkeyword">foreign-enum-keyword</a></li>
<li><a href="#index-foreign_002denum_002dvalue-88"><code>foreign-enum-value</code></a>: <a href="#foreign_002denum_002dvalue">foreign-enum-value</a></li>
<li><a href="#index-foreign_002dfree-102"><code>foreign-free</code></a>: <a href="#foreign_002dfree">foreign-free</a></li>
<li><a href="#index-foreign_002dfuncall-130"><code>foreign-funcall</code></a>: <a href="#foreign_002dfuncall">foreign-funcall</a></li>
<li><a href="#index-foreign_002dfuncall_002dpointer-131"><code>foreign-funcall-pointer</code></a>: <a href="#foreign_002dfuncall_002dpointer">foreign-funcall-pointer</a></li>
<li><a href="#index-foreign_002dpointer-101"><code>foreign-pointer</code></a>: <a href="#Basic-Pointer-Operations">Basic Pointer Operations</a></li>
<li><a href="#index-foreign_002dslot_002dnames-89"><code>foreign-slot-names</code></a>: <a href="#foreign_002dslot_002dnames">foreign-slot-names</a></li>
<li><a href="#index-foreign_002dslot_002doffset-90"><code>foreign-slot-offset</code></a>: <a href="#foreign_002dslot_002doffset">foreign-slot-offset</a></li>
<li><a href="#index-foreign_002dslot_002dpointer-91"><code>foreign-slot-pointer</code></a>: <a href="#foreign_002dslot_002dpointer">foreign-slot-pointer</a></li>
<li><a href="#index-foreign_002dslot_002dvalue-92"><code>foreign-slot-value</code></a>: <a href="#foreign_002dslot_002dvalue">foreign-slot-value</a></li>
<li><a href="#index-foreign_002dstring_002dalloc-120"><code>foreign-string-alloc</code></a>: <a href="#foreign_002dstring_002dalloc">foreign-string-alloc</a></li>
<li><a href="#index-foreign_002dstring_002dfree-121"><code>foreign-string-free</code></a>: <a href="#foreign_002dstring_002dfree">foreign-string-free</a></li>
<li><a href="#index-foreign_002dstring_002dto_002dlisp-122"><code>foreign-string-to-lisp</code></a>: <a href="#foreign_002dstring_002dto_002dlisp">foreign-string-to-lisp</a></li>
<li><a href="#index-foreign_002dsymbol_002dpointer-104"><code>foreign-symbol-pointer</code></a>: <a href="#foreign_002dsymbol_002dpointer">foreign-symbol-pointer</a></li>
<li><a href="#index-foreign_002dtype_002dalignment-93"><code>foreign-type-alignment</code></a>: <a href="#foreign_002dtype_002dalignment">foreign-type-alignment</a></li>
<li><a href="#index-foreign_002dtype_002dsize-94"><code>foreign-type-size</code></a>: <a href="#foreign_002dtype_002dsize">foreign-type-size</a></li>
<li><a href="#index-free_002dconverted_002dobject-95"><code>free-converted-object</code></a>: <a href="#free_002dconverted_002dobject">free-converted-object</a></li>
<li><a href="#index-free_002dtranslated_002dobject-96"><code>free-translated-object</code></a>: <a href="#free_002dtranslated_002dobject">free-translated-object</a></li>
<li><a href="#index-function-definition-18">function definition</a>: <a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></li>
<li><a href="#index-get_002dcallback-145"><code>get-callback</code></a>: <a href="#get_002dcallback">get-callback</a></li>
<li><a href="#index-get_002dvar_002dpointer-128"><code>get-var-pointer</code></a>: <a href="#get_002dvar_002dpointer">get-var-pointer</a></li>
<li><a href="#index-in_002dpackage-148"><code>in-package</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-inc_002dpointer-105"><code>inc-pointer</code></a>: <a href="#inc_002dpointer">inc-pointer</a></li>
<li><a href="#index-incf_002dpointer-106"><code>incf-pointer</code></a>: <a href="#incf_002dpointer">incf-pointer</a></li>
<li><a href="#index-include-147"><code>include</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-library_002c-foreign-17">library, foreign</a>: <a href="#Tutorial_002dLoading">Tutorial-Loading</a></li>
<li><a href="#index-limitations-of-type-translators-39">limitations of type translators</a>: <a href="#Tutorial_002dTypes">Tutorial-Types</a></li>
<li><a href="#index-lisp_002dstring_002dto_002dforeign-123"><code>lisp-string-to-foreign</code></a>: <a href="#lisp_002dstring_002dto_002dforeign">lisp-string-to-foreign</a></li>
<li><a href="#index-Lispy-C-functions-29">Lispy C functions</a>: <a href="#Tutorial_002dLisp-easy_005fsetopt">Tutorial-Lisp easy_setopt</a></li>
<li><a href="#index-load_002dforeign_002dlibrary-140"><code>load-foreign-library</code></a>: <a href="#load_002dforeign_002dlibrary">load-foreign-library</a></li>
<li><a href="#index-load_002dforeign_002dlibrary_002derror-141"><code>load-foreign-library-error</code></a>: <a href="#load_002dforeign_002dlibrary_002derror">load-foreign-library-error</a></li>
<li><a href="#index-loading-_0040cffi_007b_007d-14">loading <acronym>CFFI</acronym></a>: <a href="#Tutorial_002dLoading">Tutorial-Loading</a></li>
<li><a href="#index-looks-like-it-worked-20">looks like it worked</a>: <a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></li>
<li><a href="#index-make_002dpointer-107"><code>make-pointer</code></a>: <a href="#make_002dpointer">make-pointer</a></li>
<li><a href="#index-mem_002daptr-108"><code>mem-aptr</code></a>: <a href="#mem_002daptr">mem-aptr</a></li>
<li><a href="#index-mem_002daref-109"><code>mem-aref</code></a>: <a href="#mem_002daref">mem-aref</a></li>
<li><a href="#index-mem_002dref-110"><code>mem-ref</code></a>: <a href="#mem_002dref">mem-ref</a></li>
<li><a href="#index-minimal-bindings-9">minimal bindings</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-null_002dpointer-111"><code>null-pointer</code></a>: <a href="#null_002dpointer">null-pointer</a></li>
<li><a href="#index-null_002dpointer_002dp-112"><code>null-pointer-p</code></a>: <a href="#null_002dpointer_002dp">null-pointer-p</a></li>
<li><a href="#index-Perl-4">Perl</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-pointer_002daddress-114"><code>pointer-address</code></a>: <a href="#pointer_002daddress">pointer-address</a></li>
<li><a href="#index-pointer_002deq-115"><code>pointer-eq</code></a>: <a href="#pointer_002deq">pointer-eq</a></li>
<li><a href="#index-pointerp-113"><code>pointerp</code></a>: <a href="#pointerp">pointerp</a></li>
<li><a href="#index-pointers-in-Lisp-21">pointers in Lisp</a>: <a href="#Tutorial_002dInitializing">Tutorial-Initializing</a></li>
<li><a href="#index-premature-deallocation-32">premature deallocation</a>: <a href="#Tutorial_002dMemory">Tutorial-Memory</a></li>
<li><a href="#index-progn-146"><code>progn</code></a>: <a href="#Groveller-Syntax">Groveller Syntax</a></li>
<li><a href="#index-Python-5">Python</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-requiring-_0040cffi_007b_007d-15">requiring <acronym>CFFI</acronym></a>: <a href="#Tutorial_002dLoading">Tutorial-Loading</a></li>
<li><a href="#index-g_t_0040acronym_007bSLIME_007d-6"><acronym>SLIME</acronym></a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-streams-and-C-27">streams and C</a>: <a href="#Tutorial_002dAbstraction">Tutorial-Abstraction</a></li>
<li><a href="#index-strings-33">strings</a>: <a href="#Tutorial_002dMemory">Tutorial-Memory</a></li>
<li><a href="#index-g_t_0040acronym_007bSWIG_007d-3"><acronym>SWIG</acronym></a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
<li><a href="#index-translate_002dcamelcase_002dname-132"><code>translate-camelcase-name</code></a>: <a href="#translate_002dcamelcase_002dname">translate-camelcase-name</a></li>
<li><a href="#index-translate_002dfrom_002dforeign-97"><code>translate-from-foreign</code></a>: <a href="#translate_002dfrom_002dforeign">translate-from-foreign</a></li>
<li><a href="#index-translate_002dinto_002dforeign_002dmemory-99"><code>translate-into-foreign-memory</code></a>: <a href="#translate_002dinto_002dforeign_002dmemory">translate-into-foreign-memory</a></li>
<li><a href="#index-translate_002dname_002dfrom_002dforeign-133"><code>translate-name-from-foreign</code></a>: <a href="#translate_002dname_002dfrom_002dforeign">translate-name-from-foreign</a></li>
<li><a href="#index-translate_002dname_002dto_002dforeign-134"><code>translate-name-to-foreign</code></a>: <a href="#translate_002dname_002dto_002dforeign">translate-name-to-foreign</a></li>
<li><a href="#index-translate_002dto_002dforeign-98"><code>translate-to-foreign</code></a>: <a href="#translate_002dto_002dforeign">translate-to-foreign</a></li>
<li><a href="#index-translate_002dunderscore_002dseparated_002dname-135"><code>translate-underscore-separated-name</code></a>: <a href="#translate_002dunderscore_002dseparated_002dname">translate-underscore-separated-name</a></li>
<li><a href="#index-translating-types-38">translating types</a>: <a href="#Tutorial_002dTypes">Tutorial-Types</a></li>
<li><a href="#index-tutorial_002c-_0040cffi_007b_007d-1">tutorial, <acronym>CFFI</acronym></a>: <a href="#Tutorial">Tutorial</a></li>
<li><a href="#index-type-definition-36">type definition</a>: <a href="#Tutorial_002dTypes">Tutorial-Types</a></li>
<li><a href="#index-type-translators_002c-optimizing-73">type translators, optimizing</a>: <a href="#Optimizing-Type-Translators">Optimizing Type Translators</a></li>
<li><a href="#index-use_002dforeign_002dlibrary-142"><code>use-foreign-library</code></a>: <a href="#use_002dforeign_002dlibrary">use-foreign-library</a></li>
<li><a href="#index-varargs-22">varargs</a>: <a href="#Tutorial_002deasy_005fsetopt">Tutorial-easy_setopt</a></li>
<li><a href="#index-with_002dforeign_002dobject-116"><code>with-foreign-object</code></a>: <a href="#with_002dforeign_002dobject">with-foreign-object</a></li>
<li><a href="#index-with_002dforeign_002dobjects-117"><code>with-foreign-objects</code></a>: <a href="#with_002dforeign_002dobject">with-foreign-object</a></li>
<li><a href="#index-with_002dforeign_002dpointer-118"><code>with-foreign-pointer</code></a>: <a href="#with_002dforeign_002dpointer">with-foreign-pointer</a></li>
<li><a href="#index-with_002dforeign_002dpointer_002das_002dstring-126"><code>with-foreign-pointer-as-string</code></a>: <a href="#with_002dforeign_002dpointer_002das_002dstring">with-foreign-pointer-as-string</a></li>
<li><a href="#index-with_002dforeign_002dslots-100"><code>with-foreign-slots</code></a>: <a href="#with_002dforeign_002dslots">with-foreign-slots</a></li>
<li><a href="#index-with_002dforeign_002dstring-124"><code>with-foreign-string</code></a>: <a href="#with_002dforeign_002dstring">with-foreign-string</a></li>
<li><a href="#index-with_002dforeign_002dstrings-125"><code>with-foreign-strings</code></a>: <a href="#with_002dforeign_002dstring">with-foreign-string</a></li>
<li><a href="#index-workaround-for-C-12">workaround for C</a>: <a href="#Tutorial_002dComparison">Tutorial-Comparison</a></li>
   </ul><div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Admittedly, this is an
advanced issue, and we encourage you to leave this text until you are
more familiar with how <acronym>CFFI</acronym> works.</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> This does not apply to structs whose contents are
intended to be part of the public library interface.  In those cases,
a pure Lisp struct definition is always preferred.  In fact, many
prefer to stay in Lisp and break the encapsulation anyway, placing the
burden of correct library interface definition on the library.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> Specifically,
<acronym>UFFI</acronym>, an older <acronym>FFI</acronym> that takes a somewhat different
approach compared to <acronym>CFFI</acronym>.  I believe that these days (December
2005) <acronym>CFFI</acronym> is more portable and actively developed, though not as
mature yet.  Consensus in the free <span class="sc">unix</span> Common Lisp community
seems to be that <acronym>CFFI</acronym> is preferred for new development, though
<acronym>UFFI</acronym> will likely go on for quite some time as many projects
already use it.  <acronym>CFFI</acronym> includes the <code>UFFI-COMPAT</code> package for
complete compatibility with <acronym>UFFI</acronym>.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> This isn't entirely true; some Lisps
don't support <code>foreign-funcall</code>, so <code>defcfun</code> is implemented
without it.  <code>defcfun</code> may also perform optimizations that
<code>foreign-funcall</code> cannot.</p>

   <p class="footnote"><small>[<a name="fn-5" href="#fnd-5">5</a>]</small> Another possibility is to allow the caller to
specify the desired C type of the third argument.  This is essentially
what happens in a call to the function written in C.</p>

   <p class="footnote"><small>[<a name="fn-6" href="#fnd-6">6</a>]</small> See <a href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Other-Kinds-of-Streams">Other Kinds of Streams</a>, for a <acronym>GNU</acronym>-only way to extend the <code>FILE*</code>
type.  You could use this to convert Lisp streams to the needed C
data.  This would be quite involved and far outside the scope of this
tutorial.</p>

   <p class="footnote"><small>[<a name="fn-7" href="#fnd-7">7</a>]</small> &ldquo;<i>But I thought Lisp was supposed to protect
me from all that buggy C crap!</i>&rdquo;  Before asking a question like that,
remember that you are a stranger in a foreign land, whose residents
have a completely different set of values.</p>

   <p class="footnote"><small>[<a name="fn-8" href="#fnd-8">8</a>]</small> There are advantages and
disadvantages to each approach; I chose to <code>(setf
symbol-function)</code> earlier because it entailed generating fewer magic
function names.</p>

   <p class="footnote"><small>[<a name="fn-9" href="#fnd-9">9</a>]</small> Unfortunately, we can't protect against
<em>all</em> non-local exits, such as <code>return</code>s and <code>throw</code>s,
because <code>unwind-protect</code> cannot be used to &ldquo;short-circuit&rdquo; a
non-local exit in Common Lisp, due to proposal <code>minimal</code> in
<a href="http://www.lisp.org/HyperSpec/Issues/iss152-writeup.html"><acronym>ANSI</acronym> issue <span class="sc">Exit-Extent</span></a>.  Furthermore, binding an
<code>error</code> handler prevents higher-up code from invoking restarts
that may be provided under the callback's dynamic context.  Such is
the way of compromise.</p>

   <p class="footnote"><small>[<a name="fn-10" href="#fnd-10">10</a>]</small> It might be better to return
<code>(values)</code> than <code>:curle-ok</code> in real code, but this is good
for illustration.</p>

   <p class="footnote"><small>[<a name="fn-11" href="#fnd-11">11</a>]</small> The
definition of <dfn>memory</dfn> includes the <acronym>CPU</acronym> registers.</p>

   <p class="footnote"><small>[<a name="fn-12" href="#fnd-12">12</a>]</small> Windows programmers may chafe at adding a
<span class="sc">unix</span>-specific clause to <code>define-foreign-library</code>.  Instead,
ask why the Windows solution to library incompatibility is &ldquo;include
your own version of every library you use with every program&rdquo;.</p>

   <p class="footnote"><small>[<a name="fn-13" href="#fnd-13">13</a>]</small> See <a href="asdf.html#Using-asdf-to-load-systems">Using asdf to load systems</a>, for information on
<code>asdf:*central-registry*</code>.</p>

   <p class="footnote"><small>[<a name="fn-14" href="#fnd-14">14</a>]</small> See <code>mini-eval</code> in <samp><span class="file">libraries.lisp</span></samp> for
the source of this definition.  As is always the case with a Lisp
<code>eval</code>, it's easier to understand the Lisp definition than the
english.</p>

   <p class="footnote"><small>[<a name="fn-15" href="#fnd-15">15</a>]</small> Namely, <acronym>CMUCL</acronym>.  See
<code>use-foreign-library</code> in <samp><span class="file">libraries.lisp</span></samp> for details.</p>

   <hr></div>

</body></html>

